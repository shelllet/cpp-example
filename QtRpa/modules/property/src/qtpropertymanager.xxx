/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the tools applications of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 3 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL3 included in the
** packaging of this file. Please review the following information to
** ensure the GNU Lesser General Public License version 3 requirements
** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 2.0 or (at your option) the GNU General
** Public license version 3 or any later version approved by the KDE Free
** Qt Foundation. The licenses are as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-2.0.html and
** https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/
#include "property/framework.h"
#include "property/propertysheet.h"
#include "property/abstractpropertymanager.h"
#include "property/qtpropertymanager.h"
#include <QtCore/QDateTime>
#include <QtCore/QLocale>
#include <QtCore/QMap>
#include <QtCore/QTimer>
#include <QtGui/QIcon>
#include <QtCore/QMetaEnum>
#include <QtGui/QFontDatabase>
#include <QtWidgets/QStyleOption>
#include <QtWidgets/QStyle>
#include <QtWidgets/QApplication>
#include <QtGui/QPainter>
#include <QtWidgets/QLabel>

#include <limits>
#include <limits.h>
#include <float.h>

#if defined(Q_CC_MSVC)
#    pragma warning(disable: 4786) /* MS VS 6: truncating debug info after 255 characters */
#endif

QT_BEGIN_NAMESPACE
using namespace shelllet::property;
template <class PrivateData, class Value>
static void setSimpleMinimumData(PrivateData* data, const Value& minVal)
{
	data->minVal = minVal;
	if (data->maxVal < data->minVal)
		data->maxVal = data->minVal;

	if (data->val < data->minVal)
		data->val = data->minVal;
}

template <class PrivateData, class Value>
static void setSimpleMaximumData(PrivateData* data, const Value& maxVal)
{
	data->maxVal = maxVal;
	if (data->minVal > data->maxVal)
		data->minVal = data->maxVal;

	if (data->val > data->maxVal)
		data->val = data->maxVal;
}

template <class PrivateData, class Value>
static void setSizeMinimumData(PrivateData* data, const Value& newMinVal)
{
	data->minVal = newMinVal;
	if (data->maxVal.width() < data->minVal.width())
		data->maxVal.setWidth(data->minVal.width());
	if (data->maxVal.height() < data->minVal.height())
		data->maxVal.setHeight(data->minVal.height());

	if (data->val.width() < data->minVal.width())
		data->val.setWidth(data->minVal.width());
	if (data->val.height() < data->minVal.height())
		data->val.setHeight(data->minVal.height());
}

template <class PrivateData, class Value>
static void setSizeMaximumData(PrivateData* data, const Value& newMaxVal)
{
	data->maxVal = newMaxVal;
	if (data->minVal.width() > data->maxVal.width())
		data->minVal.setWidth(data->maxVal.width());
	if (data->minVal.height() > data->maxVal.height())
		data->minVal.setHeight(data->maxVal.height());

	if (data->val.width() > data->maxVal.width())
		data->val.setWidth(data->maxVal.width());
	if (data->val.height() > data->maxVal.height())
		data->val.setHeight(data->maxVal.height());
}

template <class SizeValue>
static SizeValue qBoundSize(const SizeValue& minVal, const SizeValue& val, const SizeValue& maxVal)
{
	SizeValue croppedVal = val;
	if (minVal.width() > val.width())
		croppedVal.setWidth(minVal.width());
	else if (maxVal.width() < val.width())
		croppedVal.setWidth(maxVal.width());

	if (minVal.height() > val.height())
		croppedVal.setHeight(minVal.height());
	else if (maxVal.height() < val.height())
		croppedVal.setHeight(maxVal.height());

	return croppedVal;
}

// Match the exact signature of qBound for VS 6.
QSize qBound(QSize minVal, QSize val, QSize maxVal)
{
	return qBoundSize(minVal, val, maxVal);
}

QSizeF qBound(QSizeF minVal, QSizeF val, QSizeF maxVal)
{
	return qBoundSize(minVal, val, maxVal);
}

namespace {
	namespace {
		template <class Value>
		void orderBorders(Value& minVal, Value& maxVal)
		{
			if (minVal > maxVal)
				qSwap(minVal, maxVal);
		}

		template <class Value>
		static void orderSizeBorders(Value& minVal, Value& maxVal)
		{
			Value fromSize = minVal;
			Value toSize = maxVal;
			if (fromSize.width() > toSize.width()) {
				fromSize.setWidth(maxVal.width());
				toSize.setWidth(minVal.width());
			}
			if (fromSize.height() > toSize.height()) {
				fromSize.setHeight(maxVal.height());
				toSize.setHeight(minVal.height());
			}
			minVal = fromSize;
			maxVal = toSize;
		}

		void orderBorders(QSize& minVal, QSize& maxVal)
		{
			orderSizeBorders(minVal, maxVal);
		}

		void orderBorders(QSizeF& minVal, QSizeF& maxVal)
		{
			orderSizeBorders(minVal, maxVal);
		}
	}
}
////////

template <class Value, class PrivateData>
static Value getData(const QMap<const PropertySheet*, PrivateData>& propertyMap,
	Value PrivateData::* data,
	const PropertySheet* property, const Value& defaultValue = Value())
{
	const auto it = propertyMap.constFind(property);
	if (it == propertyMap.constEnd())
		return defaultValue;
	return it.value().*data;
}

template <class Value, class PrivateData>
static Value getValue(const QMap<const PropertySheet*, PrivateData>& propertyMap,
	const PropertySheet* property, const Value& defaultValue = Value())
{
	return getData<Value>(propertyMap, &PrivateData::val, property, defaultValue);
}

template <class Value, class PrivateData>
static Value getMinimum(const QMap<const PropertySheet*, PrivateData>& propertyMap,
	const PropertySheet* property, const Value& defaultValue = Value())
{
	return getData<Value>(propertyMap, &PrivateData::minVal, property, defaultValue);
}

template <class Value, class PrivateData>
static Value getMaximum(const QMap<const PropertySheet*, PrivateData>& propertyMap,
	const PropertySheet* property, const Value& defaultValue = Value())
{
	return getData<Value>(propertyMap, &PrivateData::maxVal, property, defaultValue);
}

template <class ValueChangeParameter, class Value, class PropertyManager>
static void setSimpleValue(QMap<const PropertySheet*, Value>& propertyMap,
	PropertyManager* manager,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	PropertySheet* property, const Value& val)
{
	const auto it = propertyMap.find(property);
	if (it == propertyMap.end())
		return;

	if (it.value() == val)
		return;

	it.value() = val;

	emit(manager->*propertyChangedSignal)(property);
	emit(manager->*valueChangedSignal)(property, val);
}

template <class ValueChangeParameter, class PropertyManagerPrivate, class PropertyManager, class Value>
static void setValueInRange(PropertyManager* manager, PropertyManagerPrivate* managerPrivate,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	PropertySheet* property, const Value& val,
	void (PropertyManagerPrivate::* setSubPropertyValue)(PropertySheet*, ValueChangeParameter))
{
	const auto it = managerPrivate->m_values.find(property);
	if (it == managerPrivate->m_values.end())
		return;

	auto& data = it.value();

	if (data.val == val)
		return;

	const Value oldVal = data.val;

	data.val = qBound(data.minVal, val, data.maxVal);

	if (data.val == oldVal)
		return;

	if (setSubPropertyValue)
		(managerPrivate->*setSubPropertyValue)(property, data.val);

	emit(manager->*propertyChangedSignal)(property);
	emit(manager->*valueChangedSignal)(property, data.val);
}

template <class ValueChangeParameter, class PropertyManagerPrivate, class PropertyManager, class Value>
static void setBorderValues(PropertyManager* manager, PropertyManagerPrivate* managerPrivate,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	void (PropertyManager::* rangeChangedSignal)(PropertySheet*, ValueChangeParameter, ValueChangeParameter),
	PropertySheet* property, const Value& minVal, const Value& maxVal,
	void (PropertyManagerPrivate::* setSubPropertyRange)(PropertySheet*,
		ValueChangeParameter, ValueChangeParameter, ValueChangeParameter))
{
	const auto it = managerPrivate->m_values.find(property);
	if (it == managerPrivate->m_values.end())
		return;

	Value fromVal = minVal;
	Value toVal = maxVal;
	orderBorders(fromVal, toVal);

	auto& data = it.value();

	if (data.minVal == fromVal && data.maxVal == toVal)
		return;

	const Value oldVal = data.val;

	data.setMinimumValue(fromVal);
	data.setMaximumValue(toVal);

	emit(manager->*rangeChangedSignal)(property, data.minVal, data.maxVal);

	if (setSubPropertyRange)
		(managerPrivate->*setSubPropertyRange)(property, data.minVal, data.maxVal, data.val);

	if (data.val == oldVal)
		return;

	emit(manager->*propertyChangedSignal)(property);
	emit(manager->*valueChangedSignal)(property, data.val);
}

template <class ValueChangeParameter, class PropertyManagerPrivate, class PropertyManager, class Value, class PrivateData>
static void setBorderValue(PropertyManager* manager, PropertyManagerPrivate* managerPrivate,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	void (PropertyManager::* rangeChangedSignal)(PropertySheet*, ValueChangeParameter, ValueChangeParameter),
	PropertySheet* property,
	Value(PrivateData::* getRangeVal)() const,
	void (PrivateData::* setRangeVal)(ValueChangeParameter), const Value& borderVal,
	void (PropertyManagerPrivate::* setSubPropertyRange)(PropertySheet*,
		ValueChangeParameter, ValueChangeParameter, ValueChangeParameter))
{
	const auto it = managerPrivate->m_values.find(property);
	if (it == managerPrivate->m_values.end())
		return;

	PrivateData& data = it.value();

	if ((data.*getRangeVal)() == borderVal)
		return;

	const Value oldVal = data.val;

	(data.*setRangeVal)(borderVal);

	emit(manager->*rangeChangedSignal)(property, data.minVal, data.maxVal);

	if (setSubPropertyRange)
		(managerPrivate->*setSubPropertyRange)(property, data.minVal, data.maxVal, data.val);

	if (data.val == oldVal)
		return;

	emit(manager->*propertyChangedSignal)(property);
	emit(manager->*valueChangedSignal)(property, data.val);
}

template <class ValueChangeParameter, class PropertyManagerPrivate, class PropertyManager, class Value, class PrivateData>
static void setMinimumValue(PropertyManager* manager, PropertyManagerPrivate* managerPrivate,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	void (PropertyManager::* rangeChangedSignal)(PropertySheet*, ValueChangeParameter, ValueChangeParameter),
	PropertySheet* property, const Value& minVal)
{
	void (PropertyManagerPrivate:: * setSubPropertyRange)(PropertySheet*,
		ValueChangeParameter, ValueChangeParameter, ValueChangeParameter) = 0;
	setBorderValue<ValueChangeParameter, PropertyManagerPrivate, PropertyManager, Value, PrivateData>(manager, managerPrivate,
		propertyChangedSignal, valueChangedSignal, rangeChangedSignal,
		property, &PropertyManagerPrivate::Data::minimumValue, &PropertyManagerPrivate::Data::setMinimumValue, minVal, setSubPropertyRange);
}

template <class ValueChangeParameter, class PropertyManagerPrivate, class PropertyManager, class Value, class PrivateData>
static void setMaximumValue(PropertyManager* manager, PropertyManagerPrivate* managerPrivate,
	void (PropertyManager::* propertyChangedSignal)(PropertySheet*),
	void (PropertyManager::* valueChangedSignal)(PropertySheet*, ValueChangeParameter),
	void (PropertyManager::* rangeChangedSignal)(PropertySheet*, ValueChangeParameter, ValueChangeParameter),
	PropertySheet* property, const Value& maxVal)
{
	void (PropertyManagerPrivate:: * setSubPropertyRange)(PropertySheet*,
		ValueChangeParameter, ValueChangeParameter, ValueChangeParameter) = 0;
	setBorderValue<ValueChangeParameter, PropertyManagerPrivate, PropertyManager, Value, PrivateData>(manager, managerPrivate,
		propertyChangedSignal, valueChangedSignal, rangeChangedSignal,
		property, &PropertyManagerPrivate::Data::maximumValue, &PropertyManagerPrivate::Data::setMaximumValue, maxVal, setSubPropertyRange);
}

class QtMetaEnumWrapper : public QObject
{
	Q_OBJECT
		Q_PROPERTY(QSizePolicy::Policy policy READ policy)
public:
	QSizePolicy::Policy policy() const { return QSizePolicy::Ignored; }
private:
	QtMetaEnumWrapper(QObject* parent) : QObject(parent) {}
};

class QtMetaEnumProvider
{
public:
	QtMetaEnumProvider();

	QStringList policyEnumNames() const { return m_policyEnumNames; }
	QStringList languageEnumNames() const { return m_languageEnumNames; }
	QStringList countryEnumNames(QLocale::Language language) const { return m_countryEnumNames.value(language); }

	QSizePolicy::Policy indexToSizePolicy(int index) const;
	int sizePolicyToIndex(QSizePolicy::Policy policy) const;

	void indexToLocale(int languageIndex, int countryIndex, QLocale::Language* language, QLocale::Country* country) const;
	void localeToIndex(QLocale::Language language, QLocale::Country country, int* languageIndex, int* countryIndex) const;

private:
	void initLocale();

	QStringList m_policyEnumNames;
	QStringList m_languageEnumNames;
	QMap<QLocale::Language, QStringList> m_countryEnumNames;
	QMap<int, QLocale::Language> m_indexToLanguage;
	QMap<QLocale::Language, int> m_languageToIndex;
	QMap<int, QMap<int, QLocale::Country> > m_indexToCountry;
	QMap<QLocale::Language, QMap<QLocale::Country, int> > m_countryToIndex;
	QMetaEnum m_policyEnum;
};

static QList<QLocale::Country> sortCountries(const QList<QLocale::Country>& countries)
{
	QMultiMap<QString, QLocale::Country> nameToCountry;
	for (QLocale::Country country : countries)
		nameToCountry.insert(QLocale::countryToString(country), country);
	return nameToCountry.values();
}

void QtMetaEnumProvider::initLocale()
{
	QMultiMap<QString, QLocale::Language> nameToLanguage;
	for (int l = QLocale::C, last = QLocale::LastLanguage; l <= last; ++l) {
		const QLocale::Language language = static_cast<QLocale::Language>(l);
		QLocale locale(language);
		if (locale.language() == language)
			nameToLanguage.insert(QLocale::languageToString(language), language);
	}

	const QLocale system = QLocale::system();
	if (!nameToLanguage.contains(QLocale::languageToString(system.language())))
		nameToLanguage.insert(QLocale::languageToString(system.language()), system.language());

	const QList<QLocale::Language> languages = nameToLanguage.values();
	for (QLocale::Language language : languages) {
		QList<QLocale::Country> countries;
		countries = QLocale::countriesForLanguage(language);
		if (countries.isEmpty() && language == system.language())
			countries << system.country();

		if (!countries.isEmpty() && !m_languageToIndex.contains(language)) {
			countries = sortCountries(countries);
			int langIdx = m_languageEnumNames.count();
			m_indexToLanguage[langIdx] = language;
			m_languageToIndex[language] = langIdx;
			QStringList countryNames;
			int countryIdx = 0;
			for (QLocale::Country country : qAsConst(countries)) {
				countryNames << QLocale::countryToString(country);
				m_indexToCountry[langIdx][countryIdx] = country;
				m_countryToIndex[language][country] = countryIdx;
				++countryIdx;
			}
			m_languageEnumNames << QLocale::languageToString(language);
			m_countryEnumNames[language] = countryNames;
		}
	}
}

QtMetaEnumProvider::QtMetaEnumProvider()
{
	QMetaProperty p;

	p = QtMetaEnumWrapper::staticMetaObject.property(
		QtMetaEnumWrapper::staticMetaObject.propertyOffset() + 0);
	m_policyEnum = p.enumerator();
	const int keyCount = m_policyEnum.keyCount();
	for (int i = 0; i < keyCount; i++)
		m_policyEnumNames << QLatin1String(m_policyEnum.key(i));

	initLocale();
}

QSizePolicy::Policy QtMetaEnumProvider::indexToSizePolicy(int index) const
{
	return static_cast<QSizePolicy::Policy>(m_policyEnum.value(index));
}

int QtMetaEnumProvider::sizePolicyToIndex(QSizePolicy::Policy policy) const
{
	const int keyCount = m_policyEnum.keyCount();
	for (int i = 0; i < keyCount; i++)
		if (indexToSizePolicy(i) == policy)
			return i;
	return -1;
}

void QtMetaEnumProvider::indexToLocale(int languageIndex, int countryIndex, QLocale::Language* language, QLocale::Country* country) const
{
	QLocale::Language l = QLocale::C;
	QLocale::Country c = QLocale::AnyCountry;
	if (m_indexToLanguage.contains(languageIndex)) {
		l = m_indexToLanguage[languageIndex];
		if (m_indexToCountry.contains(languageIndex) && m_indexToCountry[languageIndex].contains(countryIndex))
			c = m_indexToCountry[languageIndex][countryIndex];
	}
	if (language)
		*language = l;
	if (country)
		*country = c;
}

void QtMetaEnumProvider::localeToIndex(QLocale::Language language, QLocale::Country country, int* languageIndex, int* countryIndex) const
{
	int l = -1;
	int c = -1;
	if (m_languageToIndex.contains(language)) {
		l = m_languageToIndex[language];
		if (m_countryToIndex.contains(language) && m_countryToIndex[language].contains(country))
			c = m_countryToIndex[language][country];
	}

	if (languageIndex)
		*languageIndex = l;
	if (countryIndex)
		*countryIndex = c;
}

Q_GLOBAL_STATIC(QtMetaEnumProvider, metaEnumProvider)


// QtIntPropertyManager

class QtIntPropertyManagerPrivate
{
	
};

/*!
	\class QtIntPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtIntPropertyManager provides and manages int properties.

	An int property has a current value, and a range specifying the
	valid values. The range is defined by a minimum and a maximum
	value.

	The property's value and range can be retrieved using the value(),
	minimum() and maximum() functions, and can be set using the
	setValue(), setMinimum() and setMaximum() slots. Alternatively,
	the range can be defined in one go using the setRange() slot.

	In addition, QtIntPropertyManager provides the valueChanged() signal which
	is emitted whenever a property created by this manager changes,
	and the rangeChanged() signal which is emitted whenever such a
	property changes its range of valid values.

	\sa AbstractPropertyManager, QtSpinBoxFactory, QtSliderFactory, QtScrollBarFactory
*/

/*!
	\fn void QtIntPropertyManager::valueChanged(PropertySheet *property, int value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtIntPropertyManager::rangeChanged(PropertySheet *property, int minimum, int maximum)

	This signal is emitted whenever a property created by this manager
	changes its range of valid values, passing a pointer to the
	\a property and the new \a minimum and \a maximum values.

	\sa setRange()
*/

/*!
	\fn void QtIntPropertyManager::singleStepChanged(PropertySheet *property, int step)

	This signal is emitted whenever a property created by this manager
	changes its single step property, passing a pointer to the
	\a property and the new \a step value

	\sa setSingleStep()
*/

/*!
	Creates a manager with the given \a parent.
*/
// QtDoublePropertyManager

class QtDoublePropertyManagerPrivate
{
	
};

/*!
	\class QtDoublePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtDoublePropertyManager provides and manages double properties.

	A double property has a current value, and a range specifying the
	valid values. The range is defined by a minimum and a maximum
	value.

	The property's value and range can be retrieved using the value(),
	minimum() and maximum() functions, and can be set using the
	setValue(), setMinimum() and setMaximum() slots.
	Alternatively, the range can be defined in one go using the
	setRange() slot.

	In addition, QtDoublePropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the rangeChanged() signal which is emitted whenever
	such a property changes its range of valid values.

	\sa AbstractPropertyManager, QtDoubleSpinBoxFactory
*/

/*!
	\fn void QtDoublePropertyManager::valueChanged(PropertySheet *property, double value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtDoublePropertyManager::rangeChanged(PropertySheet *property, double minimum, double maximum)

	This signal is emitted whenever a property created by this manager
	changes its range of valid values, passing a pointer to the
	\a property and the new \a minimum and \a maximum values

	\sa setRange()
*/

/*!
	\fn void QtDoublePropertyManager::decimalsChanged(PropertySheet *property, int prec)

	This signal is emitted whenever a property created by this manager
	changes its precision of value, passing a pointer to the
	\a property and the new \a prec value

	\sa setDecimals()
*/

/*!
	\fn void QtDoublePropertyManager::singleStepChanged(PropertySheet *property, double step)

	This signal is emitted whenever a property created by this manager
	changes its single step property, passing a pointer to the
	\a property and the new \a step value

	\sa setSingleStep()
*/

/*!
	Creates a manager with the given \a parent.
*/
// QtStringPropertyManager

class QtStringPropertyManagerPrivate
{
	
};

/*!
	\class QtStringPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtStringPropertyManager provides and manages QString properties.

	A string property's value can be retrieved using the value()
	function, and set using the setValue() slot.

	The current value can be checked against a regular expression. To
	set the regular expression use the setRegExp() slot, use the
	regExp() function to retrieve the currently set expression.

	In addition, QtStringPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the regExpChanged() signal which is emitted whenever
	such a property changes its currently set regular expression.

	\sa AbstractPropertyManager, QtLineEditFactory
*/

/*!
	\fn void QtStringPropertyManager::valueChanged(PropertySheet *property, const QString &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtStringPropertyManager::regExpChanged(PropertySheet *property, const QRegExp &regExp)

	This signal is emitted whenever a property created by this manager
	changes its currenlty set regular expression, passing a pointer to
	the \a property and the new \a regExp as parameters.

	\sa setRegExp()
*/

/*!
	Creates a manager with the given \a parent.
*/

// QtBoolPropertyManager
//     Return an icon containing a check box indicator
static QIcon drawCheckBox(bool value)
{
	QStyleOptionButton opt;
	opt.state |= value ? QStyle::State_On : QStyle::State_Off;
	opt.state |= QStyle::State_Enabled;
	const QStyle* style = QApplication::style();
	// Figure out size of an indicator and make sure it is not scaled down in a list view item
	// by making the pixmap as big as a list view icon and centering the indicator in it.
	// (if it is smaller, it can't be helped)
	const int indicatorWidth = style->pixelMetric(QStyle::PM_IndicatorWidth, &opt);
	const int indicatorHeight = style->pixelMetric(QStyle::PM_IndicatorHeight, &opt);
	const int listViewIconSize = indicatorWidth;
	const int pixmapWidth = indicatorWidth;
	const int pixmapHeight = qMax(indicatorHeight, listViewIconSize);

	opt.rect = QRect(0, 0, indicatorWidth, indicatorHeight);
	QPixmap pixmap = QPixmap(pixmapWidth, pixmapHeight);
	pixmap.fill(Qt::transparent);
	{
		// Center?
		const int xoff = (pixmapWidth > indicatorWidth) ? (pixmapWidth - indicatorWidth) / 2 : 0;
		const int yoff = (pixmapHeight > indicatorHeight) ? (pixmapHeight - indicatorHeight) / 2 : 0;
		QPainter painter(&pixmap);
		painter.translate(xoff, yoff);
		style->drawPrimitive(QStyle::PE_IndicatorCheckBox, &opt, &painter);
	}
	return QIcon(pixmap);
}

class QtBoolPropertyManagerPrivate
{
	
};


// QtDatePropertyManager

class QtDatePropertyManagerPrivate
{
	QtDatePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtDatePropertyManager)
public:
	explicit QtDatePropertyManagerPrivate(QtDatePropertyManager* q);

	struct Data
	{
		QDate val{ QDate::currentDate() };
		QDate minVal{ QDate(1752, 9, 14) };
		QDate maxVal{ QDate(9999, 12, 31) };
		QDate minimumValue() const { return minVal; }
		QDate maximumValue() const { return maxVal; }
		void setMinimumValue(const QDate& newMinVal) { setSimpleMinimumData(this, newMinVal); }
		void setMaximumValue(const QDate& newMaxVal) { setSimpleMaximumData(this, newMaxVal); }
	};

	QString m_format;

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	QMap<const PropertySheet*, Data> m_values;
};

QtDatePropertyManagerPrivate::QtDatePropertyManagerPrivate(QtDatePropertyManager* q) :
	q_ptr(q),
	m_format(QtPropertyBrowserUtils::dateFormat())
{
}

/*!
	\class QtDatePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtDatePropertyManager provides and manages QDate properties.

	A date property has a current value, and a range specifying the
	valid dates. The range is defined by a minimum and a maximum
	value.

	The property's values can be retrieved using the minimum(),
	maximum() and value() functions, and can be set using the
	setMinimum(), setMaximum() and setValue() slots. Alternatively,
	the range can be defined in one go using the setRange() slot.

	In addition, QtDatePropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the rangeChanged() signal which is emitted whenever
	such a property changes its range of valid dates.

	\sa AbstractPropertyManager, QtDateEditFactory, QtDateTimePropertyManager
*/

/*!
	\fn void QtDatePropertyManager::valueChanged(PropertySheet *property, const QDate &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtDatePropertyManager::rangeChanged(PropertySheet *property, const QDate &minimum, const QDate &maximum)

	This signal is emitted whenever a property created by this manager
	changes its range of valid dates, passing a pointer to the \a
	property and the new \a minimum and \a maximum dates.

	\sa setRange()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtDatePropertyManager::QtDatePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtDatePropertyManagerPrivate(this))
{
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtDatePropertyManager::~QtDatePropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by \e this manager, this
	function returns an invalid date.

	\sa setValue()
*/
QDate QtDatePropertyManager::value(const PropertySheet* property) const
{
	return getValue<QDate>(d_ptr->m_values, property);
}

/*!
	Returns the given \a  property's  minimum date.

	\sa maximum(), setRange()
*/
QDate QtDatePropertyManager::minimum(const PropertySheet* property) const
{
	return getMinimum<QDate>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's maximum date.

	\sa minimum(), setRange()
*/
QDate QtDatePropertyManager::maximum(const PropertySheet* property) const
{
	return getMaximum<QDate>(d_ptr->m_values, property);
}

/*!
	\reimp
*/
QString QtDatePropertyManager::valueText(const PropertySheet* property) const
{
	const QtDatePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	return it.value().val.toString(d_ptr->m_format);
}

/*!
	\fn void QtDatePropertyManager::setValue(PropertySheet *property, const QDate &value)

	Sets the value of the given \a property to \a value.

	If the specified \a value is not a valid date according to the
	given \a property's range, the value is adjusted to the nearest
	valid value within the range.

	\sa value(), setRange(), valueChanged()
*/
void QtDatePropertyManager::setValue(PropertySheet* property, const QDate& val)
{
	void (QtDatePropertyManagerPrivate:: * setSubPropertyValue)(PropertySheet*, const QDate&) = 0;
	setValueInRange<const QDate&, QtDatePropertyManagerPrivate, QtDatePropertyManager, const QDate>(this, d_ptr.data(),
		&QtDatePropertyManager::propertyChanged,
		&QtDatePropertyManager::valueChanged,
		property, val, setSubPropertyValue);
}

/*!
	Sets the minimum value for the given \a property to \a minVal.

	When setting the minimum value, the maximum and current values are
	adjusted if necessary (ensuring that the range remains valid and
	that the current value is within in the range).

	\sa minimum(), setRange()
*/
void QtDatePropertyManager::setMinimum(PropertySheet* property, const QDate& minVal)
{
	setMinimumValue<const QDate&, QtDatePropertyManagerPrivate, QtDatePropertyManager, QDate, QtDatePropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtDatePropertyManager::propertyChanged,
		&QtDatePropertyManager::valueChanged,
		&QtDatePropertyManager::rangeChanged,
		property, minVal);
}

/*!
	Sets the maximum value for the given \a property to \a maxVal.

	When setting the maximum value, the minimum and current
	values are adjusted if necessary (ensuring that the range remains
	valid and that the current value is within in the range).

	\sa maximum(), setRange()
*/
void QtDatePropertyManager::setMaximum(PropertySheet* property, const QDate& maxVal)
{
	setMaximumValue<const QDate&, QtDatePropertyManagerPrivate, QtDatePropertyManager, QDate, QtDatePropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtDatePropertyManager::propertyChanged,
		&QtDatePropertyManager::valueChanged,
		&QtDatePropertyManager::rangeChanged,
		property, maxVal);
}

/*!
	\fn void QtDatePropertyManager::setRange(PropertySheet *property, const QDate &minimum, const QDate &maximum)

	Sets the range of valid dates.

	This is a convenience function defining the range of valid dates
	in one go; setting the \a minimum and \a maximum values for the
	given \a property with a single function call.

	When setting a new date range, the current value is adjusted if
	necessary (ensuring that the value remains in date range).

	\sa setMinimum(), setMaximum(), rangeChanged()
*/
void QtDatePropertyManager::setRange(PropertySheet* property, const QDate& minVal, const QDate& maxVal)
{
	void (QtDatePropertyManagerPrivate:: * setSubPropertyRange)(PropertySheet*, const QDate&,
		const QDate&, const QDate&) = 0;
	setBorderValues<const QDate&, QtDatePropertyManagerPrivate, QtDatePropertyManager, QDate>(this, d_ptr.data(),
		&QtDatePropertyManager::propertyChanged,
		&QtDatePropertyManager::valueChanged,
		&QtDatePropertyManager::rangeChanged,
		property, minVal, maxVal, setSubPropertyRange);
}

/*!
	\reimp
*/
void QtDatePropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtDatePropertyManagerPrivate::Data();
}

/*!
	\reimp
*/
void QtDatePropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtTimePropertyManager

class QtTimePropertyManagerPrivate
{
	QtTimePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtTimePropertyManager)
public:
	explicit QtTimePropertyManagerPrivate(QtTimePropertyManager* q);

	const QString m_format;

	typedef QMap<const PropertySheet*, QTime> PropertyValueMap;
	PropertyValueMap m_values;
};

QtTimePropertyManagerPrivate::QtTimePropertyManagerPrivate(QtTimePropertyManager* q) :
	q_ptr(q),
	m_format(QtPropertyBrowserUtils::timeFormat())
{
}

/*!
	\class QtTimePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtTimePropertyManager provides and manages QTime properties.

	A time property's value can be retrieved using the value()
	function, and set using the setValue() slot.

	In addition, QtTimePropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes.

	\sa AbstractPropertyManager, QtTimeEditFactory
*/

/*!
	\fn void QtTimePropertyManager::valueChanged(PropertySheet *property, const QTime &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtTimePropertyManager::QtTimePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtTimePropertyManagerPrivate(this))
{
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtTimePropertyManager::~QtTimePropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given property is not managed by this manager, this
	function returns an invalid time object.

	\sa setValue()
*/
QTime QtTimePropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QTime());
}

/*!
	\reimp
*/
QString QtTimePropertyManager::valueText(const PropertySheet* property) const
{
	const QtTimePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	return it.value().toString(d_ptr->m_format);
}

/*!
	\fn void QtTimePropertyManager::setValue(PropertySheet *property, const QTime &value)

	Sets the value of the given \a property to \a value.

	\sa value(), valueChanged()
*/
void QtTimePropertyManager::setValue(PropertySheet* property, const QTime& val)
{
	setSimpleValue<const QTime&, QTime, QtTimePropertyManager>(d_ptr->m_values, this,
		&QtTimePropertyManager::propertyChanged,
		&QtTimePropertyManager::valueChanged,
		property, val);
}

/*!
	\reimp
*/
void QtTimePropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QTime::currentTime();
}

/*!
	\reimp
*/
void QtTimePropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtDateTimePropertyManager

class QtDateTimePropertyManagerPrivate
{
	QtDateTimePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtDateTimePropertyManager)
public:
	explicit QtDateTimePropertyManagerPrivate(QtDateTimePropertyManager* q);

	const QString m_format;

	typedef QMap<const PropertySheet*, QDateTime> PropertyValueMap;
	PropertyValueMap m_values;
};

QtDateTimePropertyManagerPrivate::QtDateTimePropertyManagerPrivate(QtDateTimePropertyManager* q) :
	q_ptr(q),
	m_format(QtPropertyBrowserUtils::dateTimeFormat())
{
}

/*! \class QtDateTimePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtDateTimePropertyManager provides and manages QDateTime properties.

	A date and time property has a current value which can be
	retrieved using the value() function, and set using the setValue()
	slot. In addition, QtDateTimePropertyManager provides the
	valueChanged() signal which is emitted whenever a property created
	by this manager changes.

	\sa AbstractPropertyManager, QtDateTimeEditFactory, QtDatePropertyManager
*/

/*!
	\fn void QtDateTimePropertyManager::valueChanged(PropertySheet *property, const QDateTime &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.
*/

/*!
	Creates a manager with the given \a parent.
*/
QtDateTimePropertyManager::QtDateTimePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtDateTimePropertyManagerPrivate(this))
{
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtDateTimePropertyManager::~QtDateTimePropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an invalid QDateTime object.

	\sa setValue()
*/
QDateTime QtDateTimePropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QDateTime());
}

/*!
	\reimp
*/
QString QtDateTimePropertyManager::valueText(const PropertySheet* property) const
{
	const QtDateTimePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	return it.value().toString(d_ptr->m_format);
}

/*!
	\fn void QtDateTimePropertyManager::setValue(PropertySheet *property, const QDateTime &value)

	Sets the value of the given \a property to \a value.

	\sa value(), valueChanged()
*/
void QtDateTimePropertyManager::setValue(PropertySheet* property, const QDateTime& val)
{
	setSimpleValue<const QDateTime&, QDateTime, QtDateTimePropertyManager>(d_ptr->m_values, this,
		&QtDateTimePropertyManager::propertyChanged,
		&QtDateTimePropertyManager::valueChanged,
		property, val);
}

/*!
	\reimp
*/
void QtDateTimePropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QDateTime::currentDateTime();
}

/*!
	\reimp
*/
void QtDateTimePropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtKeySequencePropertyManager

class QtKeySequencePropertyManagerPrivate
{
	QtKeySequencePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtKeySequencePropertyManager)
public:

	QString m_format;

	typedef QMap<const PropertySheet*, QKeySequence> PropertyValueMap;
	PropertyValueMap m_values;
};

/*! \class QtKeySequencePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtKeySequencePropertyManager provides and manages QKeySequence properties.

	A key sequence's value can be retrieved using the value()
	function, and set using the setValue() slot.

	In addition, QtKeySequencePropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes.

	\sa AbstractPropertyManager
*/

/*!
	\fn void QtKeySequencePropertyManager::valueChanged(PropertySheet *property, const QKeySequence &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.
*/

/*!
	Creates a manager with the given \a parent.
*/
QtKeySequencePropertyManager::QtKeySequencePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtKeySequencePropertyManagerPrivate)
{
	d_ptr->q_ptr = this;
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtKeySequencePropertyManager::~QtKeySequencePropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an empty QKeySequence object.

	\sa setValue()
*/
QKeySequence QtKeySequencePropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QKeySequence());
}

/*!
	\reimp
*/
QString QtKeySequencePropertyManager::valueText(const PropertySheet* property) const
{
	const QtKeySequencePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	return it.value().toString(QKeySequence::NativeText);
}

/*!
	\fn void QtKeySequencePropertyManager::setValue(PropertySheet *property, const QKeySequence &value)

	Sets the value of the given \a property to \a value.

	\sa value(), valueChanged()
*/
void QtKeySequencePropertyManager::setValue(PropertySheet* property, const QKeySequence& val)
{
	setSimpleValue<const QKeySequence&, QKeySequence, QtKeySequencePropertyManager>(d_ptr->m_values, this,
		&QtKeySequencePropertyManager::propertyChanged,
		&QtKeySequencePropertyManager::valueChanged,
		property, val);
}

/*!
	\reimp
*/
void QtKeySequencePropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QKeySequence();
}

/*!
	\reimp
*/
void QtKeySequencePropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtCharPropertyManager

class QtCharPropertyManagerPrivate
{
	QtCharPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtCharPropertyManager)
public:

	typedef QMap<const PropertySheet*, QChar> PropertyValueMap;
	PropertyValueMap m_values;
};

/*! \class QtCharPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtCharPropertyManager provides and manages QChar properties.

	A char's value can be retrieved using the value()
	function, and set using the setValue() slot.

	In addition, QtCharPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes.

	\sa AbstractPropertyManager
*/

/*!
	\fn void QtCharPropertyManager::valueChanged(PropertySheet *property, const QChar &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.
*/

/*!
	Creates a manager with the given \a parent.
*/
QtCharPropertyManager::QtCharPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtCharPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtCharPropertyManager::~QtCharPropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an null QChar object.

	\sa setValue()
*/
QChar QtCharPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QChar());
}

/*!
	\reimp
*/
QString QtCharPropertyManager::valueText(const PropertySheet* property) const
{
	const QtCharPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QChar c = it.value();
	return c.isNull() ? QString() : QString(c);
}

/*!
	\fn void QtCharPropertyManager::setValue(PropertySheet *property, const QChar &value)

	Sets the value of the given \a property to \a value.

	\sa value(), valueChanged()
*/
void QtCharPropertyManager::setValue(PropertySheet* property, const QChar& val)
{
	setSimpleValue<const QChar&, QChar, QtCharPropertyManager>(d_ptr->m_values, this,
		&QtCharPropertyManager::propertyChanged,
		&QtCharPropertyManager::valueChanged,
		property, val);
}

/*!
	\reimp
*/
void QtCharPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QChar();
}

/*!
	\reimp
*/
void QtCharPropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtLocalePropertyManager

class QtLocalePropertyManagerPrivate
{
	QtLocalePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtLocalePropertyManager)
public:

	QtLocalePropertyManagerPrivate();

	void slotEnumChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);

	typedef QMap<const PropertySheet*, QLocale> PropertyValueMap;
	PropertyValueMap m_values;

	QtEnumPropertyManager* m_enumPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToLanguage;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToCountry;

	QMap<const PropertySheet*, PropertySheet*> m_languageToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_countryToProperty;
};

QtLocalePropertyManagerPrivate::QtLocalePropertyManagerPrivate()
{
}

void QtLocalePropertyManagerPrivate::slotEnumChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_languageToProperty.value(property, 0)) {
		const QLocale loc = m_values[prop];
		QLocale::Language newLanguage = loc.language();
		QLocale::Country newCountry = loc.country();
		metaEnumProvider()->indexToLocale(value, 0, &newLanguage, 0);
		QLocale newLoc(newLanguage, newCountry);
		q_ptr->setValue(prop, newLoc);
	}
	else if (PropertySheet* prop = m_countryToProperty.value(property, 0)) {
		const QLocale loc = m_values[prop];
		QLocale::Language newLanguage = loc.language();
		QLocale::Country newCountry = loc.country();
		metaEnumProvider()->indexToLocale(m_enumPropertyManager->value(m_propertyToLanguage.value(prop)), value, &newLanguage, &newCountry);
		QLocale newLoc(newLanguage, newCountry);
		q_ptr->setValue(prop, newLoc);
	}
}

void QtLocalePropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* subProp = m_languageToProperty.value(property, 0)) {
		m_propertyToLanguage[subProp] = 0;
		m_languageToProperty.remove(property);
	}
	else if (PropertySheet* subProp = m_countryToProperty.value(property, 0)) {
		m_propertyToCountry[subProp] = 0;
		m_countryToProperty.remove(property);
	}
}

/*!
	\class QtLocalePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtLocalePropertyManager provides and manages QLocale properties.

	A locale property has nested \e language and \e country
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by QtEnumPropertyManager object.
	These submanager can be retrieved using the subEnumPropertyManager()
	function. In order to provide editing widgets for the subproperties
	in a property browser widget, this manager must be associated with editor factory.

	In addition, QtLocalePropertyManager provides the valueChanged()
	signal which is emitted whenever a property created by this
	manager changes.

	\sa AbstractPropertyManager, QtEnumPropertyManager
*/

/*!
	\fn void QtLocalePropertyManager::valueChanged(PropertySheet *property, const QLocale &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtLocalePropertyManager::QtLocalePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtLocalePropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_enumPropertyManager = new QtEnumPropertyManager(this);
	connect(d_ptr->m_enumPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotEnumChanged(PropertySheet*, int)));

	connect(d_ptr->m_enumPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtLocalePropertyManager::~QtLocalePropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e language
	and \e country subproperties.

	In order to provide editing widgets for the mentioned subproperties
	in a property browser widget, this manager must be associated with
	an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtEnumPropertyManager* QtLocalePropertyManager::subEnumPropertyManager() const
{
	return d_ptr->m_enumPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given property is not managed by this manager, this
	function returns the default locale.

	\sa setValue()
*/
QLocale QtLocalePropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QLocale());
}

/*!
	\reimp
*/
QString QtLocalePropertyManager::valueText(const PropertySheet* property) const
{
	const QtLocalePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	const QLocale loc = it.value();

	int langIdx = 0;
	int countryIdx = 0;
	const QtMetaEnumProvider* me = metaEnumProvider();
	me->localeToIndex(loc.language(), loc.country(), &langIdx, &countryIdx);
	if (langIdx < 0) {
		qWarning("QtLocalePropertyManager::valueText: Unknown language %d", loc.language());
		return tr("<Invalid>");
	}
	const QString languageName = me->languageEnumNames().at(langIdx);
	if (countryIdx < 0) {
		qWarning("QtLocalePropertyManager::valueText: Unknown country %d for %s", loc.country(), qPrintable(languageName));
		return languageName;
	}
	const QString countryName = me->countryEnumNames(loc.language()).at(countryIdx);
	return tr("%1, %2").arg(languageName, countryName);
}

/*!
	\fn void QtLocalePropertyManager::setValue(PropertySheet *property, const QLocale &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtLocalePropertyManager::setValue(PropertySheet* property, const QLocale& val)
{
	const QtLocalePropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	const QLocale loc = it.value();
	if (loc == val)
		return;

	it.value() = val;

	int langIdx = 0;
	int countryIdx = 0;
	metaEnumProvider()->localeToIndex(val.language(), val.country(), &langIdx, &countryIdx);
	if (loc.language() != val.language()) {
		d_ptr->m_enumPropertyManager->setValue(d_ptr->m_propertyToLanguage.value(property), langIdx);
		d_ptr->m_enumPropertyManager->setEnumNames(d_ptr->m_propertyToCountry.value(property),
			metaEnumProvider()->countryEnumNames(val.language()));
	}
	d_ptr->m_enumPropertyManager->setValue(d_ptr->m_propertyToCountry.value(property), countryIdx);

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\reimp
*/
void QtLocalePropertyManager::initializeProperty(PropertySheet* property)
{
	QLocale val;
	d_ptr->m_values[property] = val;

	int langIdx = 0;
	int countryIdx = 0;
	metaEnumProvider()->localeToIndex(val.language(), val.country(), &langIdx, &countryIdx);

	PropertySheet* languageProp = d_ptr->m_enumPropertyManager->addProperty();
	languageProp->setPropertyName(tr("Language"));
	d_ptr->m_enumPropertyManager->setEnumNames(languageProp, metaEnumProvider()->languageEnumNames());
	d_ptr->m_enumPropertyManager->setValue(languageProp, langIdx);
	d_ptr->m_propertyToLanguage[property] = languageProp;
	d_ptr->m_languageToProperty[languageProp] = property;
	property->addSubProperty(languageProp);

	PropertySheet* countryProp = d_ptr->m_enumPropertyManager->addProperty();
	countryProp->setPropertyName(tr("Country"));
	d_ptr->m_enumPropertyManager->setEnumNames(countryProp, metaEnumProvider()->countryEnumNames(val.language()));
	d_ptr->m_enumPropertyManager->setValue(countryProp, countryIdx);
	d_ptr->m_propertyToCountry[property] = countryProp;
	d_ptr->m_countryToProperty[countryProp] = property;
	property->addSubProperty(countryProp);
}

/*!
	\reimp
*/
void QtLocalePropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* languageProp = d_ptr->m_propertyToLanguage[property];
	if (languageProp) {
		d_ptr->m_languageToProperty.remove(languageProp);
		delete languageProp;
	}
	d_ptr->m_propertyToLanguage.remove(property);

	PropertySheet* countryProp = d_ptr->m_propertyToCountry[property];
	if (countryProp) {
		d_ptr->m_countryToProperty.remove(countryProp);
		delete countryProp;
	}
	d_ptr->m_propertyToCountry.remove(property);

	d_ptr->m_values.remove(property);
}

// QtPointPropertyManager

class QtPointPropertyManagerPrivate
{
	QtPointPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtPointPropertyManager)
public:

	void slotIntChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);

	typedef QMap<const PropertySheet*, QPoint> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToX;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToY;

	QMap<const PropertySheet*, PropertySheet*> m_xToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_yToProperty;
};

void QtPointPropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (PropertySheet* xprop = m_xToProperty.value(property, 0)) {
		QPoint p = m_values[xprop];
		p.setX(value);
		q_ptr->setValue(xprop, p);
	}
	else if (PropertySheet* yprop = m_yToProperty.value(property, 0)) {
		QPoint p = m_values[yprop];
		p.setY(value);
		q_ptr->setValue(yprop, p);
	}
}

void QtPointPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_xToProperty.value(property, 0)) {
		m_propertyToX[pointProp] = 0;
		m_xToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_yToProperty.value(property, 0)) {
		m_propertyToY[pointProp] = 0;
		m_yToProperty.remove(property);
	}
}

/*! \class QtPointPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtPointPropertyManager provides and manages QPoint properties.

	A point property has nested \e x and \e y subproperties. The
	top-level property's value can be retrieved using the value()
	function, and set using the setValue() slot.

	The subproperties are created by a QtIntPropertyManager object. This
	manager can be retrieved using the subIntPropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	In addition, QtPointPropertyManager provides the valueChanged() signal which
	is emitted whenever a property created by this manager changes.

	\sa AbstractPropertyManager, QtIntPropertyManager, QtPointFPropertyManager
*/

/*!
	\fn void QtPointPropertyManager::valueChanged(PropertySheet *property, const QPoint &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtPointPropertyManager::QtPointPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtPointPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));
	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtPointPropertyManager::~QtPointPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e x and \e y
	subproperties.

	In order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtPointPropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns a point with coordinates (0, 0).

	\sa setValue()
*/
QPoint QtPointPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QPoint());
}

/*!
	\reimp
*/
QString QtPointPropertyManager::valueText(const PropertySheet* property) const
{
	const QtPointPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QPoint v = it.value();
	return tr("(%1, %2)").arg(QString::number(v.x()))
		.arg(QString::number(v.y()));
}

/*!
	\fn void QtPointPropertyManager::setValue(PropertySheet *property, const QPoint &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtPointPropertyManager::setValue(PropertySheet* property, const QPoint& val)
{
	const QtPointPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	if (it.value() == val)
		return;

	it.value() = val;
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToX[property], val.x());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToY[property], val.y());

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\reimp
*/
void QtPointPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QPoint(0, 0);

	PropertySheet* xProp = d_ptr->m_intPropertyManager->addProperty();
	xProp->setPropertyName(tr("X"));
	d_ptr->m_intPropertyManager->setValue(xProp, 0);
	d_ptr->m_propertyToX[property] = xProp;
	d_ptr->m_xToProperty[xProp] = property;
	property->addSubProperty(xProp);

	PropertySheet* yProp = d_ptr->m_intPropertyManager->addProperty();
	yProp->setPropertyName(tr("Y"));
	d_ptr->m_intPropertyManager->setValue(yProp, 0);
	d_ptr->m_propertyToY[property] = yProp;
	d_ptr->m_yToProperty[yProp] = property;
	property->addSubProperty(yProp);
}

/*!
	\reimp
*/
void QtPointPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* xProp = d_ptr->m_propertyToX[property];
	if (xProp) {
		d_ptr->m_xToProperty.remove(xProp);
		delete xProp;
	}
	d_ptr->m_propertyToX.remove(property);

	PropertySheet* yProp = d_ptr->m_propertyToY[property];
	if (yProp) {
		d_ptr->m_yToProperty.remove(yProp);
		delete yProp;
	}
	d_ptr->m_propertyToY.remove(property);

	d_ptr->m_values.remove(property);
}

// QtPointFPropertyManager

class QtPointFPropertyManagerPrivate
{
	QtPointFPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtPointFPropertyManager)
public:

	struct Data
	{
		QPointF val;
		int decimals{ 2 };
	};

	void slotDoubleChanged(PropertySheet* property, double value);
	void slotPropertyDestroyed(PropertySheet* property);

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtDoublePropertyManager* m_doublePropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToX;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToY;

	QMap<const PropertySheet*, PropertySheet*> m_xToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_yToProperty;
};

void QtPointFPropertyManagerPrivate::slotDoubleChanged(PropertySheet* property, double value)
{
	if (PropertySheet* prop = m_xToProperty.value(property, 0)) {
		QPointF p = m_values[prop].val;
		p.setX(value);
		q_ptr->setValue(prop, p);
	}
	else if (PropertySheet* prop = m_yToProperty.value(property, 0)) {
		QPointF p = m_values[prop].val;
		p.setY(value);
		q_ptr->setValue(prop, p);
	}
}

void QtPointFPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_xToProperty.value(property, 0)) {
		m_propertyToX[pointProp] = 0;
		m_xToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_yToProperty.value(property, 0)) {
		m_propertyToY[pointProp] = 0;
		m_yToProperty.remove(property);
	}
}

/*! \class QtPointFPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtPointFPropertyManager provides and manages QPointF properties.

	A point property has nested \e x and \e y subproperties. The
	top-level property's value can be retrieved using the value()
	function, and set using the setValue() slot.

	The subproperties are created by a QtDoublePropertyManager object. This
	manager can be retrieved using the subDoublePropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	In addition, QtPointFPropertyManager provides the valueChanged() signal which
	is emitted whenever a property created by this manager changes.

	\sa AbstractPropertyManager, QtDoublePropertyManager, QtPointPropertyManager
*/

/*!
	\fn void QtPointFPropertyManager::valueChanged(PropertySheet *property, const QPointF &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtPointFPropertyManager::decimalsChanged(PropertySheet *property, int prec)

	This signal is emitted whenever a property created by this manager
	changes its precision of value, passing a pointer to the
	\a property and the new \a prec value

	\sa setDecimals()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtPointFPropertyManager::QtPointFPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtPointFPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_doublePropertyManager = new QtDoublePropertyManager(this);
	connect(d_ptr->m_doublePropertyManager, SIGNAL(valueChanged(PropertySheet*, double)),
		this, SLOT(slotDoubleChanged(PropertySheet*, double)));
	connect(d_ptr->m_doublePropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtPointFPropertyManager::~QtPointFPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e x and \e y
	subproperties.

	In order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtDoublePropertyManager* QtPointFPropertyManager::subDoublePropertyManager() const
{
	return d_ptr->m_doublePropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns a point with coordinates (0, 0).

	\sa setValue()
*/
QPointF QtPointFPropertyManager::value(const PropertySheet* property) const
{
	return getValue<QPointF>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's precision, in decimals.

	\sa setDecimals()
*/
int QtPointFPropertyManager::decimals(const PropertySheet* property) const
{
	return getData<int>(d_ptr->m_values, &QtPointFPropertyManagerPrivate::Data::decimals, property, 0);
}

/*!
	\reimp
*/
QString QtPointFPropertyManager::valueText(const PropertySheet* property) const
{
	const QtPointFPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QPointF v = it.value().val;
	const int dec = it.value().decimals;
	return tr("(%1, %2)").arg(QString::number(v.x(), 'f', dec))
		.arg(QString::number(v.y(), 'f', dec));
}

/*!
	\fn void QtPointFPropertyManager::setValue(PropertySheet *property, const QPointF &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtPointFPropertyManager::setValue(PropertySheet* property, const QPointF& val)
{
	const QtPointFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	if (it.value().val == val)
		return;

	it.value().val = val;
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToX[property], val.x());
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToY[property], val.y());

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\fn void QtPointFPropertyManager::setDecimals(PropertySheet *property, int prec)

	Sets the precision of the given \a property to \a prec.

	The valid decimal range is 0-13. The default is 2.

	\sa decimals()
*/
void QtPointFPropertyManager::setDecimals(PropertySheet* property, int prec)
{
	const QtPointFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtPointFPropertyManagerPrivate::Data data = it.value();

	if (prec > 13)
		prec = 13;
	else if (prec < 0)
		prec = 0;

	if (data.decimals == prec)
		return;

	data.decimals = prec;
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToX[property], prec);
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToY[property], prec);

	it.value() = data;

	emit decimalsChanged(property, data.decimals);
}

/*!
	\reimp
*/
void QtPointFPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtPointFPropertyManagerPrivate::Data();

	PropertySheet* xProp = d_ptr->m_doublePropertyManager->addProperty();
	xProp->setPropertyName(tr("X"));
	d_ptr->m_doublePropertyManager->setDecimals(xProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(xProp, 0);
	d_ptr->m_propertyToX[property] = xProp;
	d_ptr->m_xToProperty[xProp] = property;
	property->addSubProperty(xProp);

	PropertySheet* yProp = d_ptr->m_doublePropertyManager->addProperty();
	yProp->setPropertyName(tr("Y"));
	d_ptr->m_doublePropertyManager->setDecimals(yProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(yProp, 0);
	d_ptr->m_propertyToY[property] = yProp;
	d_ptr->m_yToProperty[yProp] = property;
	property->addSubProperty(yProp);
}

/*!
	\reimp
*/
void QtPointFPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* xProp = d_ptr->m_propertyToX[property];
	if (xProp) {
		d_ptr->m_xToProperty.remove(xProp);
		delete xProp;
	}
	d_ptr->m_propertyToX.remove(property);

	PropertySheet* yProp = d_ptr->m_propertyToY[property];
	if (yProp) {
		d_ptr->m_yToProperty.remove(yProp);
		delete yProp;
	}
	d_ptr->m_propertyToY.remove(property);

	d_ptr->m_values.remove(property);
}

// QtSizePropertyManager

class QtSizePropertyManagerPrivate
{
	QtSizePropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtSizePropertyManager)
public:

	void slotIntChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);
	void setValue(PropertySheet* property, const QSize& val);
	void setRange(PropertySheet* property,
		const QSize& minVal, const QSize& maxVal, const QSize& val);

	struct Data
	{
		QSize val{ 0, 0 };
		QSize minVal{ 0, 0 };
		QSize maxVal{ INT_MAX, INT_MAX };
		QSize minimumValue() const { return minVal; }
		QSize maximumValue() const { return maxVal; }
		void setMinimumValue(const QSize& newMinVal) { setSizeMinimumData(this, newMinVal); }
		void setMaximumValue(const QSize& newMaxVal) { setSizeMaximumData(this, newMaxVal); }
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToW;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToH;

	QMap<const PropertySheet*, PropertySheet*> m_wToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_hToProperty;
};

void QtSizePropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_wToProperty.value(property, 0)) {
		QSize s = m_values[prop].val;
		s.setWidth(value);
		q_ptr->setValue(prop, s);
	}
	else if (PropertySheet* prop = m_hToProperty.value(property, 0)) {
		QSize s = m_values[prop].val;
		s.setHeight(value);
		q_ptr->setValue(prop, s);
	}
}

void QtSizePropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_wToProperty.value(property, 0)) {
		m_propertyToW[pointProp] = 0;
		m_wToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_hToProperty.value(property, 0)) {
		m_propertyToH[pointProp] = 0;
		m_hToProperty.remove(property);
	}
}

void QtSizePropertyManagerPrivate::setValue(PropertySheet* property, const QSize& val)
{
	m_intPropertyManager->setValue(m_propertyToW.value(property), val.width());
	m_intPropertyManager->setValue(m_propertyToH.value(property), val.height());
}

void QtSizePropertyManagerPrivate::setRange(PropertySheet* property,
	const QSize& minVal, const QSize& maxVal, const QSize& val)
{
	PropertySheet* wProperty = m_propertyToW.value(property);
	PropertySheet* hProperty = m_propertyToH.value(property);
	m_intPropertyManager->setRange(wProperty, minVal.width(), maxVal.width());
	m_intPropertyManager->setValue(wProperty, val.width());
	m_intPropertyManager->setRange(hProperty, minVal.height(), maxVal.height());
	m_intPropertyManager->setValue(hProperty, val.height());
}

/*!
	\class QtSizePropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtSizePropertyManager provides and manages QSize properties.

	A size property has nested \e width and \e height
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by a QtIntPropertyManager object. This
	manager can be retrieved using the subIntPropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	A size property also has a range of valid values defined by a
	minimum size and a maximum size. These sizes can be retrieved
	using the minimum() and the maximum() functions, and set using the
	setMinimum() and setMaximum() slots. Alternatively, the range can
	be defined in one go using the setRange() slot.

	In addition, QtSizePropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the rangeChanged() signal which is emitted whenever
	such a property changes its range of valid sizes.

	\sa AbstractPropertyManager, QtIntPropertyManager, QtSizeFPropertyManager
*/

/*!
	\fn void QtSizePropertyManager::valueChanged(PropertySheet *property, const QSize &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtSizePropertyManager::rangeChanged(PropertySheet *property, const QSize &minimum, const QSize &maximum)

	This signal is emitted whenever a property created by this manager
	changes its range of valid sizes, passing a pointer to the \a
	property and the new \a minimum and \a maximum sizes.

	\sa setRange()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtSizePropertyManager::QtSizePropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtSizePropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));
	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtSizePropertyManager::~QtSizePropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e width and \e height
	subproperties.

	In order to provide editing widgets for the \e width and \e height
	properties in a property browser widget, this manager must be
	associated with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtSizePropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an invalid size

	\sa setValue()
*/
QSize QtSizePropertyManager::value(const PropertySheet* property) const
{
	return getValue<QSize>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's minimum size value.

	\sa setMinimum(), maximum(), setRange()
*/
QSize QtSizePropertyManager::minimum(const PropertySheet* property) const
{
	return getMinimum<QSize>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's maximum size value.

	\sa setMaximum(), minimum(), setRange()
*/
QSize QtSizePropertyManager::maximum(const PropertySheet* property) const
{
	return getMaximum<QSize>(d_ptr->m_values, property);
}

/*!
	\reimp
*/
QString QtSizePropertyManager::valueText(const PropertySheet* property) const
{
	const QtSizePropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QSize v = it.value().val;
	return tr("%1 x %2").arg(QString::number(v.width()))
		.arg(QString::number(v.height()));
}

/*!
	\fn void QtSizePropertyManager::setValue(PropertySheet *property, const QSize &value)

	Sets the value of the given \a property to \a value.

	If the specified \a value is not valid according to the given \a
	property's size range, the \a value is adjusted to the nearest
	valid value within the size range.

	\sa value(), setRange(), valueChanged()
*/
void QtSizePropertyManager::setValue(PropertySheet* property, const QSize& val)
{
	setValueInRange<const QSize&, QtSizePropertyManagerPrivate, QtSizePropertyManager, const QSize>(this, d_ptr.data(),
		&QtSizePropertyManager::propertyChanged,
		&QtSizePropertyManager::valueChanged,
		property, val, &QtSizePropertyManagerPrivate::setValue);
}

/*!
	Sets the minimum size value for the given \a property to \a minVal.

	When setting the minimum size value, the maximum and current
	values are adjusted if necessary (ensuring that the size range
	remains valid and that the current value is within the range).

	\sa minimum(), setRange(), rangeChanged()
*/
void QtSizePropertyManager::setMinimum(PropertySheet* property, const QSize& minVal)
{
	setBorderValue<const QSize&, QtSizePropertyManagerPrivate, QtSizePropertyManager, QSize, QtSizePropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtSizePropertyManager::propertyChanged,
		&QtSizePropertyManager::valueChanged,
		&QtSizePropertyManager::rangeChanged,
		property,
		&QtSizePropertyManagerPrivate::Data::minimumValue,
		&QtSizePropertyManagerPrivate::Data::setMinimumValue,
		minVal, &QtSizePropertyManagerPrivate::setRange);
}

/*!
	Sets the maximum size value for the given \a property to \a maxVal.

	When setting the maximum size value, the minimum and current
	values are adjusted if necessary (ensuring that the size range
	remains valid and that the current value is within the range).

	\sa maximum(), setRange(), rangeChanged()
*/
void QtSizePropertyManager::setMaximum(PropertySheet* property, const QSize& maxVal)
{
	setBorderValue<const QSize&, QtSizePropertyManagerPrivate, QtSizePropertyManager, QSize, QtSizePropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtSizePropertyManager::propertyChanged,
		&QtSizePropertyManager::valueChanged,
		&QtSizePropertyManager::rangeChanged,
		property,
		&QtSizePropertyManagerPrivate::Data::maximumValue,
		&QtSizePropertyManagerPrivate::Data::setMaximumValue,
		maxVal, &QtSizePropertyManagerPrivate::setRange);
}

/*!
	\fn void QtSizePropertyManager::setRange(PropertySheet *property, const QSize &minimum, const QSize &maximum)

	Sets the range of valid values.

	This is a convenience function defining the range of valid values
	in one go; setting the \a minimum and \a maximum values for the
	given \a property with a single function call.

	When setting a new range, the current value is adjusted if
	necessary (ensuring that the value remains within the range).

	\sa setMinimum(), setMaximum(), rangeChanged()
*/
void QtSizePropertyManager::setRange(PropertySheet* property, const QSize& minVal, const QSize& maxVal)
{
	setBorderValues<const QSize&, QtSizePropertyManagerPrivate, QtSizePropertyManager, QSize>(this, d_ptr.data(),
		&QtSizePropertyManager::propertyChanged,
		&QtSizePropertyManager::valueChanged,
		&QtSizePropertyManager::rangeChanged,
		property, minVal, maxVal, &QtSizePropertyManagerPrivate::setRange);
}

/*!
	\reimp
*/
void QtSizePropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtSizePropertyManagerPrivate::Data();

	PropertySheet* wProp = d_ptr->m_intPropertyManager->addProperty();
	wProp->setPropertyName(tr("Width"));
	d_ptr->m_intPropertyManager->setValue(wProp, 0);
	d_ptr->m_intPropertyManager->setMinimum(wProp, 0);
	d_ptr->m_propertyToW[property] = wProp;
	d_ptr->m_wToProperty[wProp] = property;
	property->addSubProperty(wProp);

	PropertySheet* hProp = d_ptr->m_intPropertyManager->addProperty();
	hProp->setPropertyName(tr("Height"));
	d_ptr->m_intPropertyManager->setValue(hProp, 0);
	d_ptr->m_intPropertyManager->setMinimum(hProp, 0);
	d_ptr->m_propertyToH[property] = hProp;
	d_ptr->m_hToProperty[hProp] = property;
	property->addSubProperty(hProp);
}

/*!
	\reimp
*/
void QtSizePropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* wProp = d_ptr->m_propertyToW[property];
	if (wProp) {
		d_ptr->m_wToProperty.remove(wProp);
		delete wProp;
	}
	d_ptr->m_propertyToW.remove(property);

	PropertySheet* hProp = d_ptr->m_propertyToH[property];
	if (hProp) {
		d_ptr->m_hToProperty.remove(hProp);
		delete hProp;
	}
	d_ptr->m_propertyToH.remove(property);

	d_ptr->m_values.remove(property);
}

// QtSizeFPropertyManager

class QtSizeFPropertyManagerPrivate
{
	QtSizeFPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtSizeFPropertyManager)
public:

	void slotDoubleChanged(PropertySheet* property, double value);
	void slotPropertyDestroyed(PropertySheet* property);
	void setValue(PropertySheet* property, const QSizeF& val);
	void setRange(PropertySheet* property,
		const QSizeF& minVal, const QSizeF& maxVal, const QSizeF& val);

	struct Data
	{
		QSizeF val{ 0, 0 };
		QSizeF minVal{ 0, 0 };
		QSizeF maxVal{ std::numeric_limits<qreal>::max(), std::numeric_limits<qreal>::max() };
		int decimals{ 2 };
		QSizeF minimumValue() const { return minVal; }
		QSizeF maximumValue() const { return maxVal; }
		void setMinimumValue(const QSizeF& newMinVal) { setSizeMinimumData(this, newMinVal); }
		void setMaximumValue(const QSizeF& newMaxVal) { setSizeMaximumData(this, newMaxVal); }
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtDoublePropertyManager* m_doublePropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToW;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToH;

	QMap<const PropertySheet*, PropertySheet*> m_wToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_hToProperty;
};

void QtSizeFPropertyManagerPrivate::slotDoubleChanged(PropertySheet* property, double value)
{
	if (PropertySheet* prop = m_wToProperty.value(property, 0)) {
		QSizeF s = m_values[prop].val;
		s.setWidth(value);
		q_ptr->setValue(prop, s);
	}
	else if (PropertySheet* prop = m_hToProperty.value(property, 0)) {
		QSizeF s = m_values[prop].val;
		s.setHeight(value);
		q_ptr->setValue(prop, s);
	}
}

void QtSizeFPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_wToProperty.value(property, 0)) {
		m_propertyToW[pointProp] = 0;
		m_wToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_hToProperty.value(property, 0)) {
		m_propertyToH[pointProp] = 0;
		m_hToProperty.remove(property);
	}
}

void QtSizeFPropertyManagerPrivate::setValue(PropertySheet* property, const QSizeF& val)
{
	m_doublePropertyManager->setValue(m_propertyToW.value(property), val.width());
	m_doublePropertyManager->setValue(m_propertyToH.value(property), val.height());
}

void QtSizeFPropertyManagerPrivate::setRange(PropertySheet* property,
	const QSizeF& minVal, const QSizeF& maxVal, const QSizeF& val)
{
	m_doublePropertyManager->setRange(m_propertyToW[property], minVal.width(), maxVal.width());
	m_doublePropertyManager->setValue(m_propertyToW[property], val.width());
	m_doublePropertyManager->setRange(m_propertyToH[property], minVal.height(), maxVal.height());
	m_doublePropertyManager->setValue(m_propertyToH[property], val.height());
}

/*!
	\class QtSizeFPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtSizeFPropertyManager provides and manages QSizeF properties.

	A size property has nested \e width and \e height
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by a QtDoublePropertyManager object. This
	manager can be retrieved using the subDoublePropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	A size property also has a range of valid values defined by a
	minimum size and a maximum size. These sizes can be retrieved
	using the minimum() and the maximum() functions, and set using the
	setMinimum() and setMaximum() slots. Alternatively, the range can
	be defined in one go using the setRange() slot.

	In addition, QtSizeFPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the rangeChanged() signal which is emitted whenever
	such a property changes its range of valid sizes.

	\sa AbstractPropertyManager, QtDoublePropertyManager, QtSizePropertyManager
*/

/*!
	\fn void QtSizeFPropertyManager::valueChanged(PropertySheet *property, const QSizeF &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtSizeFPropertyManager::rangeChanged(PropertySheet *property, const QSizeF &minimum, const QSizeF &maximum)

	This signal is emitted whenever a property created by this manager
	changes its range of valid sizes, passing a pointer to the \a
	property and the new \a minimum and \a maximum sizes.

	\sa setRange()
*/

/*!
	\fn void QtSizeFPropertyManager::decimalsChanged(PropertySheet *property, int prec)

	This signal is emitted whenever a property created by this manager
	changes its precision of value, passing a pointer to the
	\a property and the new \a prec value

	\sa setDecimals()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtSizeFPropertyManager::QtSizeFPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtSizeFPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_doublePropertyManager = new QtDoublePropertyManager(this);
	connect(d_ptr->m_doublePropertyManager, SIGNAL(valueChanged(PropertySheet*, double)),
		this, SLOT(slotDoubleChanged(PropertySheet*, double)));
	connect(d_ptr->m_doublePropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtSizeFPropertyManager::~QtSizeFPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e width and \e height
	subproperties.

	In order to provide editing widgets for the \e width and \e height
	properties in a property browser widget, this manager must be
	associated with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtDoublePropertyManager* QtSizeFPropertyManager::subDoublePropertyManager() const
{
	return d_ptr->m_doublePropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an invalid size

	\sa setValue()
*/
QSizeF QtSizeFPropertyManager::value(const PropertySheet* property) const
{
	return getValue<QSizeF>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's precision, in decimals.

	\sa setDecimals()
*/
int QtSizeFPropertyManager::decimals(const PropertySheet* property) const
{
	return getData<int>(d_ptr->m_values, &QtSizeFPropertyManagerPrivate::Data::decimals, property, 0);
}

/*!
	Returns the given \a property's minimum size value.

	\sa setMinimum(), maximum(), setRange()
*/
QSizeF QtSizeFPropertyManager::minimum(const PropertySheet* property) const
{
	return getMinimum<QSizeF>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's maximum size value.

	\sa setMaximum(), minimum(), setRange()
*/
QSizeF QtSizeFPropertyManager::maximum(const PropertySheet* property) const
{
	return getMaximum<QSizeF>(d_ptr->m_values, property);
}

/*!
	\reimp
*/
QString QtSizeFPropertyManager::valueText(const PropertySheet* property) const
{
	const QtSizeFPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QSizeF v = it.value().val;
	const int dec = it.value().decimals;
	return tr("%1 x %2").arg(QString::number(v.width(), 'f', dec))
		.arg(QString::number(v.height(), 'f', dec));
}

/*!
	\fn void QtSizeFPropertyManager::setValue(PropertySheet *property, const QSizeF &value)

	Sets the value of the given \a property to \a value.

	If the specified \a value is not valid according to the given \a
	property's size range, the \a value is adjusted to the nearest
	valid value within the size range.

	\sa value(), setRange(), valueChanged()
*/
void QtSizeFPropertyManager::setValue(PropertySheet* property, const QSizeF& val)
{
	setValueInRange<const QSizeF&, QtSizeFPropertyManagerPrivate, QtSizeFPropertyManager, QSizeF>(this, d_ptr.data(),
		&QtSizeFPropertyManager::propertyChanged,
		&QtSizeFPropertyManager::valueChanged,
		property, val, &QtSizeFPropertyManagerPrivate::setValue);
}

/*!
	\fn void QtSizeFPropertyManager::setDecimals(PropertySheet *property, int prec)

	Sets the precision of the given \a property to \a prec.

	The valid decimal range is 0-13. The default is 2.

	\sa decimals()
*/
void QtSizeFPropertyManager::setDecimals(PropertySheet* property, int prec)
{
	const QtSizeFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtSizeFPropertyManagerPrivate::Data data = it.value();

	if (prec > 13)
		prec = 13;
	else if (prec < 0)
		prec = 0;

	if (data.decimals == prec)
		return;

	data.decimals = prec;
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToW[property], prec);
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToH[property], prec);

	it.value() = data;

	emit decimalsChanged(property, data.decimals);
}

/*!
	Sets the minimum size value for the given \a property to \a minVal.

	When setting the minimum size value, the maximum and current
	values are adjusted if necessary (ensuring that the size range
	remains valid and that the current value is within the range).

	\sa minimum(), setRange(), rangeChanged()
*/
void QtSizeFPropertyManager::setMinimum(PropertySheet* property, const QSizeF& minVal)
{
	setBorderValue<const QSizeF&, QtSizeFPropertyManagerPrivate, QtSizeFPropertyManager, QSizeF, QtSizeFPropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtSizeFPropertyManager::propertyChanged,
		&QtSizeFPropertyManager::valueChanged,
		&QtSizeFPropertyManager::rangeChanged,
		property,
		&QtSizeFPropertyManagerPrivate::Data::minimumValue,
		&QtSizeFPropertyManagerPrivate::Data::setMinimumValue,
		minVal, &QtSizeFPropertyManagerPrivate::setRange);
}

/*!
	Sets the maximum size value for the given \a property to \a maxVal.

	When setting the maximum size value, the minimum and current
	values are adjusted if necessary (ensuring that the size range
	remains valid and that the current value is within the range).

	\sa maximum(), setRange(), rangeChanged()
*/
void QtSizeFPropertyManager::setMaximum(PropertySheet* property, const QSizeF& maxVal)
{
	setBorderValue<const QSizeF&, QtSizeFPropertyManagerPrivate, QtSizeFPropertyManager, QSizeF, QtSizeFPropertyManagerPrivate::Data>(this, d_ptr.data(),
		&QtSizeFPropertyManager::propertyChanged,
		&QtSizeFPropertyManager::valueChanged,
		&QtSizeFPropertyManager::rangeChanged,
		property,
		&QtSizeFPropertyManagerPrivate::Data::maximumValue,
		&QtSizeFPropertyManagerPrivate::Data::setMaximumValue,
		maxVal, &QtSizeFPropertyManagerPrivate::setRange);
}

/*!
	\fn void QtSizeFPropertyManager::setRange(PropertySheet *property, const QSizeF &minimum, const QSizeF &maximum)

	Sets the range of valid values.

	This is a convenience function defining the range of valid values
	in one go; setting the \a minimum and \a maximum values for the
	given \a property with a single function call.

	When setting a new range, the current value is adjusted if
	necessary (ensuring that the value remains within the range).

	\sa setMinimum(), setMaximum(), rangeChanged()
*/
void QtSizeFPropertyManager::setRange(PropertySheet* property, const QSizeF& minVal, const QSizeF& maxVal)
{
	setBorderValues<const QSizeF&, QtSizeFPropertyManagerPrivate, QtSizeFPropertyManager, QSizeF>(this, d_ptr.data(),
		&QtSizeFPropertyManager::propertyChanged,
		&QtSizeFPropertyManager::valueChanged,
		&QtSizeFPropertyManager::rangeChanged,
		property, minVal, maxVal, &QtSizeFPropertyManagerPrivate::setRange);
}

/*!
	\reimp
*/
void QtSizeFPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtSizeFPropertyManagerPrivate::Data();

	PropertySheet* wProp = d_ptr->m_doublePropertyManager->addProperty();
	wProp->setPropertyName(tr("Width"));
	d_ptr->m_doublePropertyManager->setDecimals(wProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(wProp, 0);
	d_ptr->m_doublePropertyManager->setMinimum(wProp, 0);
	d_ptr->m_propertyToW[property] = wProp;
	d_ptr->m_wToProperty[wProp] = property;
	property->addSubProperty(wProp);

	PropertySheet* hProp = d_ptr->m_doublePropertyManager->addProperty();
	hProp->setPropertyName(tr("Height"));
	d_ptr->m_doublePropertyManager->setDecimals(hProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(hProp, 0);
	d_ptr->m_doublePropertyManager->setMinimum(hProp, 0);
	d_ptr->m_propertyToH[property] = hProp;
	d_ptr->m_hToProperty[hProp] = property;
	property->addSubProperty(hProp);
}

/*!
	\reimp
*/
void QtSizeFPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* wProp = d_ptr->m_propertyToW[property];
	if (wProp) {
		d_ptr->m_wToProperty.remove(wProp);
		delete wProp;
	}
	d_ptr->m_propertyToW.remove(property);

	PropertySheet* hProp = d_ptr->m_propertyToH[property];
	if (hProp) {
		d_ptr->m_hToProperty.remove(hProp);
		delete hProp;
	}
	d_ptr->m_propertyToH.remove(property);

	d_ptr->m_values.remove(property);
}

// QtRectPropertyManager

class QtRectPropertyManagerPrivate
{
	QtRectPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtRectPropertyManager)
public:

	void slotIntChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);
	void setConstraint(PropertySheet* property, const QRect& constraint, const QRect& val);

	struct Data
	{
		QRect val{ 0, 0, 0, 0 };
		QRect constraint;
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToX;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToY;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToW;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToH;

	QMap<const PropertySheet*, PropertySheet*> m_xToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_yToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_wToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_hToProperty;
};

void QtRectPropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_xToProperty.value(property, 0)) {
		QRect r = m_values[prop].val;
		r.moveLeft(value);
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_yToProperty.value(property)) {
		QRect r = m_values[prop].val;
		r.moveTop(value);
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_wToProperty.value(property, 0)) {
		Data data = m_values[prop];
		QRect r = data.val;
		r.setWidth(value);
		if (!data.constraint.isNull() && data.constraint.x() + data.constraint.width() < r.x() + r.width()) {
			r.moveLeft(data.constraint.left() + data.constraint.width() - r.width());
		}
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_hToProperty.value(property, 0)) {
		Data data = m_values[prop];
		QRect r = data.val;
		r.setHeight(value);
		if (!data.constraint.isNull() && data.constraint.y() + data.constraint.height() < r.y() + r.height()) {
			r.moveTop(data.constraint.top() + data.constraint.height() - r.height());
		}
		q_ptr->setValue(prop, r);
	}
}

void QtRectPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_xToProperty.value(property, 0)) {
		m_propertyToX[pointProp] = 0;
		m_xToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_yToProperty.value(property, 0)) {
		m_propertyToY[pointProp] = 0;
		m_yToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_wToProperty.value(property, 0)) {
		m_propertyToW[pointProp] = 0;
		m_wToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_hToProperty.value(property, 0)) {
		m_propertyToH[pointProp] = 0;
		m_hToProperty.remove(property);
	}
}

void QtRectPropertyManagerPrivate::setConstraint(PropertySheet* property,
	const QRect& constraint, const QRect& val)
{
	const bool isNull = constraint.isNull();
	const int left = isNull ? INT_MIN : constraint.left();
	const int right = isNull ? INT_MAX : constraint.left() + constraint.width();
	const int top = isNull ? INT_MIN : constraint.top();
	const int bottom = isNull ? INT_MAX : constraint.top() + constraint.height();
	const int width = isNull ? INT_MAX : constraint.width();
	const int height = isNull ? INT_MAX : constraint.height();

	m_intPropertyManager->setRange(m_propertyToX[property], left, right);
	m_intPropertyManager->setRange(m_propertyToY[property], top, bottom);
	m_intPropertyManager->setRange(m_propertyToW[property], 0, width);
	m_intPropertyManager->setRange(m_propertyToH[property], 0, height);

	m_intPropertyManager->setValue(m_propertyToX[property], val.x());
	m_intPropertyManager->setValue(m_propertyToY[property], val.y());
	m_intPropertyManager->setValue(m_propertyToW[property], val.width());
	m_intPropertyManager->setValue(m_propertyToH[property], val.height());
}

/*!
	\class QtRectPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtRectPropertyManager provides and manages QRect properties.

	A rectangle property has nested \e x, \e y, \e width and \e height
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by a QtIntPropertyManager object. This
	manager can be retrieved using the subIntPropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	A rectangle property also has a constraint rectangle which can be
	retrieved using the constraint() function, and set using the
	setConstraint() slot.

	In addition, QtRectPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the constraintChanged() signal which is emitted
	whenever such a property changes its constraint rectangle.

	\sa AbstractPropertyManager, QtIntPropertyManager, QtRectFPropertyManager
*/

/*!
	\fn void QtRectPropertyManager::valueChanged(PropertySheet *property, const QRect &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtRectPropertyManager::constraintChanged(PropertySheet *property, const QRect &constraint)

	This signal is emitted whenever property changes its constraint
	rectangle, passing a pointer to the \a property and the new \a
	constraint rectangle as parameters.

	\sa setConstraint()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtRectPropertyManager::QtRectPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtRectPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));
	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtRectPropertyManager::~QtRectPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e x, \e y, \e width
	and \e height subproperties.

	In order to provide editing widgets for the mentioned
	subproperties in a property browser widget, this manager must be
	associated with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtRectPropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an invalid rectangle.

	\sa setValue(), constraint()
*/
QRect QtRectPropertyManager::value(const PropertySheet* property) const
{
	return getValue<QRect>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's constraining rectangle. If returned value is null QRect it means there is no constraint applied.

	\sa value(), setConstraint()
*/
QRect QtRectPropertyManager::constraint(const PropertySheet* property) const
{
	return getData<QRect>(d_ptr->m_values, &QtRectPropertyManagerPrivate::Data::constraint, property, QRect());
}

/*!
	\reimp
*/
QString QtRectPropertyManager::valueText(const PropertySheet* property) const
{
	const QtRectPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QRect v = it.value().val;
	return tr("[(%1, %2), %3 x %4]").arg(QString::number(v.x()))
		.arg(QString::number(v.y()))
		.arg(QString::number(v.width()))
		.arg(QString::number(v.height()));
}

/*!
	\fn void QtRectPropertyManager::setValue(PropertySheet *property, const QRect &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	If the specified \a value is not inside the given \a property's
	constraining rectangle, the value is adjusted accordingly to fit
	within the constraint.

	\sa value(), setConstraint(), valueChanged()
*/
void QtRectPropertyManager::setValue(PropertySheet* property, const QRect& val)
{
	const QtRectPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtRectPropertyManagerPrivate::Data data = it.value();

	QRect newRect = val.normalized();
	if (!data.constraint.isNull() && !data.constraint.contains(newRect)) {
		const QRect r1 = data.constraint;
		const QRect r2 = newRect;
		newRect.setLeft(qMax(r1.left(), r2.left()));
		newRect.setRight(qMin(r1.right(), r2.right()));
		newRect.setTop(qMax(r1.top(), r2.top()));
		newRect.setBottom(qMin(r1.bottom(), r2.bottom()));
		if (newRect.width() < 0 || newRect.height() < 0)
			return;
	}

	if (data.val == newRect)
		return;

	data.val = newRect;

	it.value() = data;
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToX[property], newRect.x());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToY[property], newRect.y());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToW[property], newRect.width());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToH[property], newRect.height());

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	Sets the given \a property's constraining rectangle to \a
	constraint.

	When setting the constraint, the current value is adjusted if
	necessary (ensuring that the current rectangle value is inside the
	constraint). In order to reset the constraint pass a null QRect value.

	\sa setValue(), constraint(), constraintChanged()
*/
void QtRectPropertyManager::setConstraint(PropertySheet* property, const QRect& constraint)
{
	const QtRectPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtRectPropertyManagerPrivate::Data data = it.value();

	QRect newConstraint = constraint.normalized();
	if (data.constraint == newConstraint)
		return;

	const QRect oldVal = data.val;

	data.constraint = newConstraint;

	if (!data.constraint.isNull() && !data.constraint.contains(oldVal)) {
		QRect r1 = data.constraint;
		QRect r2 = data.val;

		if (r2.width() > r1.width())
			r2.setWidth(r1.width());
		if (r2.height() > r1.height())
			r2.setHeight(r1.height());
		if (r2.left() < r1.left())
			r2.moveLeft(r1.left());
		else if (r2.right() > r1.right())
			r2.moveRight(r1.right());
		if (r2.top() < r1.top())
			r2.moveTop(r1.top());
		else if (r2.bottom() > r1.bottom())
			r2.moveBottom(r1.bottom());

		data.val = r2;
	}

	it.value() = data;

	emit constraintChanged(property, data.constraint);

	d_ptr->setConstraint(property, data.constraint, data.val);

	if (data.val == oldVal)
		return;

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	\reimp
*/
void QtRectPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtRectPropertyManagerPrivate::Data();

	PropertySheet* xProp = d_ptr->m_intPropertyManager->addProperty();
	xProp->setPropertyName(tr("X"));
	d_ptr->m_intPropertyManager->setValue(xProp, 0);
	d_ptr->m_propertyToX[property] = xProp;
	d_ptr->m_xToProperty[xProp] = property;
	property->addSubProperty(xProp);

	PropertySheet* yProp = d_ptr->m_intPropertyManager->addProperty();
	yProp->setPropertyName(tr("Y"));
	d_ptr->m_intPropertyManager->setValue(yProp, 0);
	d_ptr->m_propertyToY[property] = yProp;
	d_ptr->m_yToProperty[yProp] = property;
	property->addSubProperty(yProp);

	PropertySheet* wProp = d_ptr->m_intPropertyManager->addProperty();
	wProp->setPropertyName(tr("Width"));
	d_ptr->m_intPropertyManager->setValue(wProp, 0);
	d_ptr->m_intPropertyManager->setMinimum(wProp, 0);
	d_ptr->m_propertyToW[property] = wProp;
	d_ptr->m_wToProperty[wProp] = property;
	property->addSubProperty(wProp);

	PropertySheet* hProp = d_ptr->m_intPropertyManager->addProperty();
	hProp->setPropertyName(tr("Height"));
	d_ptr->m_intPropertyManager->setValue(hProp, 0);
	d_ptr->m_intPropertyManager->setMinimum(hProp, 0);
	d_ptr->m_propertyToH[property] = hProp;
	d_ptr->m_hToProperty[hProp] = property;
	property->addSubProperty(hProp);
}

/*!
	\reimp
*/
void QtRectPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* xProp = d_ptr->m_propertyToX[property];
	if (xProp) {
		d_ptr->m_xToProperty.remove(xProp);
		delete xProp;
	}
	d_ptr->m_propertyToX.remove(property);

	PropertySheet* yProp = d_ptr->m_propertyToY[property];
	if (yProp) {
		d_ptr->m_yToProperty.remove(yProp);
		delete yProp;
	}
	d_ptr->m_propertyToY.remove(property);

	PropertySheet* wProp = d_ptr->m_propertyToW[property];
	if (wProp) {
		d_ptr->m_wToProperty.remove(wProp);
		delete wProp;
	}
	d_ptr->m_propertyToW.remove(property);

	PropertySheet* hProp = d_ptr->m_propertyToH[property];
	if (hProp) {
		d_ptr->m_hToProperty.remove(hProp);
		delete hProp;
	}
	d_ptr->m_propertyToH.remove(property);

	d_ptr->m_values.remove(property);
}

// QtRectFPropertyManager

class QtRectFPropertyManagerPrivate
{
	QtRectFPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtRectFPropertyManager)
public:

	void slotDoubleChanged(PropertySheet* property, double value);
	void slotPropertyDestroyed(PropertySheet* property);
	void setConstraint(PropertySheet* property, const QRectF& constraint, const QRectF& val);

	struct Data
	{
		QRectF val{ 0, 0, 0, 0 };
		QRectF constraint;
		int decimals{ 2 };
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtDoublePropertyManager* m_doublePropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToX;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToY;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToW;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToH;

	QMap<const PropertySheet*, PropertySheet*> m_xToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_yToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_wToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_hToProperty;
};

void QtRectFPropertyManagerPrivate::slotDoubleChanged(PropertySheet* property, double value)
{
	if (PropertySheet* prop = m_xToProperty.value(property, 0)) {
		QRectF r = m_values[prop].val;
		r.moveLeft(value);
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_yToProperty.value(property, 0)) {
		QRectF r = m_values[prop].val;
		r.moveTop(value);
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_wToProperty.value(property, 0)) {
		Data data = m_values[prop];
		QRectF r = data.val;
		r.setWidth(value);
		if (!data.constraint.isNull() && data.constraint.x() + data.constraint.width() < r.x() + r.width()) {
			r.moveLeft(data.constraint.left() + data.constraint.width() - r.width());
		}
		q_ptr->setValue(prop, r);
	}
	else if (PropertySheet* prop = m_hToProperty.value(property, 0)) {
		Data data = m_values[prop];
		QRectF r = data.val;
		r.setHeight(value);
		if (!data.constraint.isNull() && data.constraint.y() + data.constraint.height() < r.y() + r.height()) {
			r.moveTop(data.constraint.top() + data.constraint.height() - r.height());
		}
		q_ptr->setValue(prop, r);
	}
}

void QtRectFPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_xToProperty.value(property, 0)) {
		m_propertyToX[pointProp] = 0;
		m_xToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_yToProperty.value(property, 0)) {
		m_propertyToY[pointProp] = 0;
		m_yToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_wToProperty.value(property, 0)) {
		m_propertyToW[pointProp] = 0;
		m_wToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_hToProperty.value(property, 0)) {
		m_propertyToH[pointProp] = 0;
		m_hToProperty.remove(property);
	}
}

void QtRectFPropertyManagerPrivate::setConstraint(PropertySheet* property,
	const QRectF& constraint, const QRectF& val)
{
	const bool isNull = constraint.isNull();
	const float left = isNull ? FLT_MIN : constraint.left();
	const float right = isNull ? FLT_MAX : constraint.left() + constraint.width();
	const float top = isNull ? FLT_MIN : constraint.top();
	const float bottom = isNull ? FLT_MAX : constraint.top() + constraint.height();
	const float width = isNull ? FLT_MAX : constraint.width();
	const float height = isNull ? FLT_MAX : constraint.height();

	m_doublePropertyManager->setRange(m_propertyToX[property], left, right);
	m_doublePropertyManager->setRange(m_propertyToY[property], top, bottom);
	m_doublePropertyManager->setRange(m_propertyToW[property], 0, width);
	m_doublePropertyManager->setRange(m_propertyToH[property], 0, height);

	m_doublePropertyManager->setValue(m_propertyToX[property], val.x());
	m_doublePropertyManager->setValue(m_propertyToY[property], val.y());
	m_doublePropertyManager->setValue(m_propertyToW[property], val.width());
	m_doublePropertyManager->setValue(m_propertyToH[property], val.height());
}

/*!
	\class QtRectFPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtRectFPropertyManager provides and manages QRectF properties.

	A rectangle property has nested \e x, \e y, \e width and \e height
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by a QtDoublePropertyManager object. This
	manager can be retrieved using the subDoublePropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	A rectangle property also has a constraint rectangle which can be
	retrieved using the constraint() function, and set using the
	setConstraint() slot.

	In addition, QtRectFPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the constraintChanged() signal which is emitted
	whenever such a property changes its constraint rectangle.

	\sa AbstractPropertyManager, QtDoublePropertyManager, QtRectPropertyManager
*/

/*!
	\fn void QtRectFPropertyManager::valueChanged(PropertySheet *property, const QRectF &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtRectFPropertyManager::constraintChanged(PropertySheet *property, const QRectF &constraint)

	This signal is emitted whenever property changes its constraint
	rectangle, passing a pointer to the \a property and the new \a
	constraint rectangle as parameters.

	\sa setConstraint()
*/

/*!
	\fn void QtRectFPropertyManager::decimalsChanged(PropertySheet *property, int prec)

	This signal is emitted whenever a property created by this manager
	changes its precision of value, passing a pointer to the
	\a property and the new \a prec value

	\sa setDecimals()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtRectFPropertyManager::QtRectFPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtRectFPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_doublePropertyManager = new QtDoublePropertyManager(this);
	connect(d_ptr->m_doublePropertyManager, SIGNAL(valueChanged(PropertySheet*, double)),
		this, SLOT(slotDoubleChanged(PropertySheet*, double)));
	connect(d_ptr->m_doublePropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtRectFPropertyManager::~QtRectFPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e x, \e y, \e width
	and \e height subproperties.

	In order to provide editing widgets for the mentioned
	subproperties in a property browser widget, this manager must be
	associated with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtDoublePropertyManager* QtRectFPropertyManager::subDoublePropertyManager() const
{
	return d_ptr->m_doublePropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns an invalid rectangle.

	\sa setValue(), constraint()
*/
QRectF QtRectFPropertyManager::value(const PropertySheet* property) const
{
	return getValue<QRectF>(d_ptr->m_values, property);
}

/*!
	Returns the given \a property's precision, in decimals.

	\sa setDecimals()
*/
int QtRectFPropertyManager::decimals(const PropertySheet* property) const
{
	return getData<int>(d_ptr->m_values, &QtRectFPropertyManagerPrivate::Data::decimals, property, 0);
}

/*!
	Returns the given \a property's constraining rectangle. If returned value is null QRectF it means there is no constraint applied.

	\sa value(), setConstraint()
*/
QRectF QtRectFPropertyManager::constraint(const PropertySheet* property) const
{
	return getData<QRectF>(d_ptr->m_values, &QtRectFPropertyManagerPrivate::Data::constraint, property, QRect());
}

/*!
	\reimp
*/
QString QtRectFPropertyManager::valueText(const PropertySheet* property) const
{
	const QtRectFPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();
	const QRectF v = it.value().val;
	const int dec = it.value().decimals;
	return QString(tr("[(%1, %2), %3 x %4]").arg(QString::number(v.x(), 'f', dec))
		.arg(QString::number(v.y(), 'f', dec))
		.arg(QString::number(v.width(), 'f', dec))
		.arg(QString::number(v.height(), 'f', dec)));
}

/*!
	\fn void QtRectFPropertyManager::setValue(PropertySheet *property, const QRectF &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	If the specified \a value is not inside the given \a property's
	constraining rectangle, the value is adjusted accordingly to fit
	within the constraint.

	\sa value(), setConstraint(), valueChanged()
*/
void QtRectFPropertyManager::setValue(PropertySheet* property, const QRectF& val)
{
	const QtRectFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtRectFPropertyManagerPrivate::Data data = it.value();

	QRectF newRect = val.normalized();
	if (!data.constraint.isNull() && !data.constraint.contains(newRect)) {
		const QRectF r1 = data.constraint;
		const QRectF r2 = newRect;
		newRect.setLeft(qMax(r1.left(), r2.left()));
		newRect.setRight(qMin(r1.right(), r2.right()));
		newRect.setTop(qMax(r1.top(), r2.top()));
		newRect.setBottom(qMin(r1.bottom(), r2.bottom()));
		if (newRect.width() < 0 || newRect.height() < 0)
			return;
	}

	if (data.val == newRect)
		return;

	data.val = newRect;

	it.value() = data;
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToX[property], newRect.x());
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToY[property], newRect.y());
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToW[property], newRect.width());
	d_ptr->m_doublePropertyManager->setValue(d_ptr->m_propertyToH[property], newRect.height());

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	Sets the given \a property's constraining rectangle to \a
	constraint.

	When setting the constraint, the current value is adjusted if
	necessary (ensuring that the current rectangle value is inside the
	constraint). In order to reset the constraint pass a null QRectF value.

	\sa setValue(), constraint(), constraintChanged()
*/
void QtRectFPropertyManager::setConstraint(PropertySheet* property, const QRectF& constraint)
{
	const QtRectFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtRectFPropertyManagerPrivate::Data data = it.value();

	QRectF newConstraint = constraint.normalized();
	if (data.constraint == newConstraint)
		return;

	const QRectF oldVal = data.val;

	data.constraint = newConstraint;

	if (!data.constraint.isNull() && !data.constraint.contains(oldVal)) {
		QRectF r1 = data.constraint;
		QRectF r2 = data.val;

		if (r2.width() > r1.width())
			r2.setWidth(r1.width());
		if (r2.height() > r1.height())
			r2.setHeight(r1.height());
		if (r2.left() < r1.left())
			r2.moveLeft(r1.left());
		else if (r2.right() > r1.right())
			r2.moveRight(r1.right());
		if (r2.top() < r1.top())
			r2.moveTop(r1.top());
		else if (r2.bottom() > r1.bottom())
			r2.moveBottom(r1.bottom());

		data.val = r2;
	}

	it.value() = data;

	emit constraintChanged(property, data.constraint);

	d_ptr->setConstraint(property, data.constraint, data.val);

	if (data.val == oldVal)
		return;

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	\fn void QtRectFPropertyManager::setDecimals(PropertySheet *property, int prec)

	Sets the precision of the given \a property to \a prec.

	The valid decimal range is 0-13. The default is 2.

	\sa decimals()
*/
void QtRectFPropertyManager::setDecimals(PropertySheet* property, int prec)
{
	const QtRectFPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtRectFPropertyManagerPrivate::Data data = it.value();

	if (prec > 13)
		prec = 13;
	else if (prec < 0)
		prec = 0;

	if (data.decimals == prec)
		return;

	data.decimals = prec;
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToX[property], prec);
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToY[property], prec);
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToW[property], prec);
	d_ptr->m_doublePropertyManager->setDecimals(d_ptr->m_propertyToH[property], prec);

	it.value() = data;

	emit decimalsChanged(property, data.decimals);
}

/*!
	\reimp
*/
void QtRectFPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtRectFPropertyManagerPrivate::Data();

	PropertySheet* xProp = d_ptr->m_doublePropertyManager->addProperty();
	xProp->setPropertyName(tr("X"));
	d_ptr->m_doublePropertyManager->setDecimals(xProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(xProp, 0);
	d_ptr->m_propertyToX[property] = xProp;
	d_ptr->m_xToProperty[xProp] = property;
	property->addSubProperty(xProp);

	PropertySheet* yProp = d_ptr->m_doublePropertyManager->addProperty();
	yProp->setPropertyName(tr("Y"));
	d_ptr->m_doublePropertyManager->setDecimals(yProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(yProp, 0);
	d_ptr->m_propertyToY[property] = yProp;
	d_ptr->m_yToProperty[yProp] = property;
	property->addSubProperty(yProp);

	PropertySheet* wProp = d_ptr->m_doublePropertyManager->addProperty();
	wProp->setPropertyName(tr("Width"));
	d_ptr->m_doublePropertyManager->setDecimals(wProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(wProp, 0);
	d_ptr->m_doublePropertyManager->setMinimum(wProp, 0);
	d_ptr->m_propertyToW[property] = wProp;
	d_ptr->m_wToProperty[wProp] = property;
	property->addSubProperty(wProp);

	PropertySheet* hProp = d_ptr->m_doublePropertyManager->addProperty();
	hProp->setPropertyName(tr("Height"));
	d_ptr->m_doublePropertyManager->setDecimals(hProp, decimals(property));
	d_ptr->m_doublePropertyManager->setValue(hProp, 0);
	d_ptr->m_doublePropertyManager->setMinimum(hProp, 0);
	d_ptr->m_propertyToH[property] = hProp;
	d_ptr->m_hToProperty[hProp] = property;
	property->addSubProperty(hProp);
}

/*!
	\reimp
*/
void QtRectFPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* xProp = d_ptr->m_propertyToX[property];
	if (xProp) {
		d_ptr->m_xToProperty.remove(xProp);
		delete xProp;
	}
	d_ptr->m_propertyToX.remove(property);

	PropertySheet* yProp = d_ptr->m_propertyToY[property];
	if (yProp) {
		d_ptr->m_yToProperty.remove(yProp);
		delete yProp;
	}
	d_ptr->m_propertyToY.remove(property);

	PropertySheet* wProp = d_ptr->m_propertyToW[property];
	if (wProp) {
		d_ptr->m_wToProperty.remove(wProp);
		delete wProp;
	}
	d_ptr->m_propertyToW.remove(property);

	PropertySheet* hProp = d_ptr->m_propertyToH[property];
	if (hProp) {
		d_ptr->m_hToProperty.remove(hProp);
		delete hProp;
	}
	d_ptr->m_propertyToH.remove(property);

	d_ptr->m_values.remove(property);
}

// QtEnumPropertyManager

class QtEnumPropertyManagerPrivate
{
	QtEnumPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtEnumPropertyManager)
public:

	struct Data
	{
		int val{ -1 };
		QStringList enumNames;
		QMap<int, QIcon> enumIcons;
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;
};

/*!
	\class QtEnumPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtEnumPropertyManager provides and manages enum properties.

	Each enum property has an associated list of enum names which can
	be retrieved using the enumNames() function, and set using the
	corresponding setEnumNames() function. An enum property's value is
	represented by an index in this list, and can be retrieved and set
	using the value() and setValue() slots respectively.

	Each enum value can also have an associated icon. The mapping from
	values to icons can be set using the setEnumIcons() function and
	queried with the enumIcons() function.

	In addition, QtEnumPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes. The enumNamesChanged() or enumIconsChanged() signal is emitted
	whenever the list of enum names or icons is altered.

	\sa AbstractPropertyManager, QtEnumEditorFactory
*/

/*!
	\fn void QtEnumPropertyManager::valueChanged(PropertySheet *property, int value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtEnumPropertyManager::enumNamesChanged(PropertySheet *property, const QStringList &names)

	This signal is emitted whenever a property created by this manager
	changes its enum names, passing a pointer to the \a property and
	the new \a names as parameters.

	\sa setEnumNames()
*/

/*!
	\fn void QtEnumPropertyManager::enumIconsChanged(PropertySheet *property, const QMap<int, QIcon> &icons)

	This signal is emitted whenever a property created by this manager
	changes its enum icons, passing a pointer to the \a property and
	the new mapping of values to \a icons as parameters.

	\sa setEnumIcons()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtEnumPropertyManager::QtEnumPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtEnumPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtEnumPropertyManager::~QtEnumPropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value which is an index in the
	list returned by enumNames()

	If the given property is not managed by this manager, this
	function returns -1.

	\sa enumNames(), setValue()
*/
int QtEnumPropertyManager::value(const PropertySheet* property) const
{
	return getValue<int>(d_ptr->m_values, property, -1);
}

/*!
	Returns the given \a property's list of enum names.

	\sa value(), setEnumNames()
*/
QStringList QtEnumPropertyManager::enumNames(const PropertySheet* property) const
{
	return getData<QStringList>(d_ptr->m_values, &QtEnumPropertyManagerPrivate::Data::enumNames, property, QStringList());
}

/*!
	Returns the given \a property's map of enum values to their icons.

	\sa value(), setEnumIcons()
*/
QMap<int, QIcon> QtEnumPropertyManager::enumIcons(const PropertySheet* property) const
{
	return getData<QMap<int, QIcon> >(d_ptr->m_values, &QtEnumPropertyManagerPrivate::Data::enumIcons, property, QMap<int, QIcon>());
}

/*!
	\reimp
*/
QString QtEnumPropertyManager::valueText(const PropertySheet* property) const
{
	const QtEnumPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	const QtEnumPropertyManagerPrivate::Data& data = it.value();

	const int v = data.val;
	if (v >= 0 && v < data.enumNames.count())
		return data.enumNames.at(v);
	return QString();
}

/*!
	\reimp
*/
QIcon QtEnumPropertyManager::valueIcon(const PropertySheet* property) const
{
	const QtEnumPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QIcon();

	const QtEnumPropertyManagerPrivate::Data& data = it.value();

	const int v = data.val;
	return data.enumIcons.value(v);
}

/*!
	\fn void QtEnumPropertyManager::setValue(PropertySheet *property, int value)

	Sets the value of the given  \a property to \a value.

	The specified \a value must be less than the size of the given \a
	property's enumNames() list, and larger than (or equal to) 0.

	\sa value(), valueChanged()
*/
void QtEnumPropertyManager::setValue(PropertySheet* property, int val)
{
	const QtEnumPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtEnumPropertyManagerPrivate::Data data = it.value();

	if (val >= data.enumNames.count())
		return;

	if (val < 0 && data.enumNames.count() > 0)
		return;

	if (val < 0)
		val = -1;

	if (data.val == val)
		return;

	data.val = val;

	it.value() = data;

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	Sets the given \a property's list of enum names to \a
	enumNames. The \a property's current value is reset to 0
	indicating the first item of the list.

	If the specified \a enumNames list is empty, the \a property's
	current value is set to -1.

	\sa enumNames(), enumNamesChanged()
*/
void QtEnumPropertyManager::setEnumNames(PropertySheet* property, const QStringList& enumNames)
{
	const QtEnumPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtEnumPropertyManagerPrivate::Data data = it.value();

	if (data.enumNames == enumNames)
		return;

	data.enumNames = enumNames;

	data.val = -1;

	if (enumNames.count() > 0)
		data.val = 0;

	it.value() = data;

	emit enumNamesChanged(property, data.enumNames);

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	Sets the given \a property's map of enum values to their icons to \a
	enumIcons.

	Each enum value can have associated icon. This association is represented with passed \a enumIcons map.

	\sa enumNames(), enumNamesChanged()
*/
void QtEnumPropertyManager::setEnumIcons(PropertySheet* property, const QMap<int, QIcon>& enumIcons)
{
	const QtEnumPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	it.value().enumIcons = enumIcons;

	emit enumIconsChanged(property, it.value().enumIcons);

	emit propertyChanged(property);
}

/*!
	\reimp
*/
void QtEnumPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtEnumPropertyManagerPrivate::Data();
}

/*!
	\reimp
*/
void QtEnumPropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

// QtFlagPropertyManager

class QtFlagPropertyManagerPrivate
{
	QtFlagPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtFlagPropertyManager)
public:

	void slotBoolChanged(PropertySheet* property, bool value);
	void slotPropertyDestroyed(PropertySheet* property);

	struct Data
	{
		int val{ -1 };
		QStringList flagNames;
	};

	typedef QMap<const PropertySheet*, Data> PropertyValueMap;
	PropertyValueMap m_values;

	QtBoolPropertyManager* m_boolPropertyManager;

	QMap<const PropertySheet*, QList<PropertySheet*> > m_propertyToFlags;

	QMap<const PropertySheet*, PropertySheet*> m_flagToProperty;
};

void QtFlagPropertyManagerPrivate::slotBoolChanged(PropertySheet* property, bool value)
{
	PropertySheet* prop = m_flagToProperty.value(property, 0);
	if (prop == 0)
		return;

	const auto pfit = m_propertyToFlags.constFind(prop);
	if (pfit == m_propertyToFlags.constEnd())
		return;
	int level = 0;
	for (PropertySheet* p : pfit.value()) {
		if (p == property) {
			int v = m_values[prop].val;
			if (value) {
				v |= (1 << level);
			}
			else {
				v &= ~(1 << level);
			}
			q_ptr->setValue(prop, v);
			return;
		}
		level++;
	}
}

void QtFlagPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	PropertySheet* flagProperty = m_flagToProperty.value(property, 0);
	if (flagProperty == 0)
		return;

	m_propertyToFlags[flagProperty].replace(m_propertyToFlags[flagProperty].indexOf(property), 0);
	m_flagToProperty.remove(property);
}

/*!
	\class QtFlagPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtFlagPropertyManager provides and manages flag properties.

	Each flag property has an associated list of flag names which can
	be retrieved using the flagNames() function, and set using the
	corresponding setFlagNames() function.

	The flag manager provides properties with nested boolean
	subproperties representing each flag, i.e. a flag property's value
	is the binary combination of the subproperties' values. A
	property's value can be retrieved and set using the value() and
	setValue() slots respectively. The combination of flags is represented
	by single int value - that's why it's possible to store up to
	32 independent flags in one flag property.

	The subproperties are created by a QtBoolPropertyManager object. This
	manager can be retrieved using the subBoolPropertyManager() function. In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	In addition, QtFlagPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes, and the flagNamesChanged() signal which is emitted
	whenever the list of flag names is altered.

	\sa AbstractPropertyManager, QtBoolPropertyManager
*/

/*!
	\fn void QtFlagPropertyManager::valueChanged(PropertySheet *property, int value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a  property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	\fn void QtFlagPropertyManager::flagNamesChanged(PropertySheet *property, const QStringList &names)

	This signal is emitted whenever a property created by this manager
	changes its flag names, passing a pointer to the \a property and the
	new \a names as parameters.

	\sa setFlagNames()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtFlagPropertyManager::QtFlagPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtFlagPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_boolPropertyManager = new QtBoolPropertyManager(this);
	connect(d_ptr->m_boolPropertyManager, SIGNAL(valueChanged(PropertySheet*, bool)),
		this, SLOT(slotBoolChanged(PropertySheet*, bool)));
	connect(d_ptr->m_boolPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtFlagPropertyManager::~QtFlagPropertyManager()
{
	clear();
}

/*!
	Returns the manager that produces the nested boolean subproperties
	representing each flag.

	In order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtBoolPropertyManager* QtFlagPropertyManager::subBoolPropertyManager() const
{
	return d_ptr->m_boolPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given property is not managed by this manager, this
	function returns 0.

	\sa flagNames(), setValue()
*/
int QtFlagPropertyManager::value(const PropertySheet* property) const
{
	return getValue<int>(d_ptr->m_values, property, 0);
}

/*!
	Returns the given \a property's list of flag names.

	\sa value(), setFlagNames()
*/
QStringList QtFlagPropertyManager::flagNames(const PropertySheet* property) const
{
	return getData<QStringList>(d_ptr->m_values, &QtFlagPropertyManagerPrivate::Data::flagNames, property, QStringList());
}

/*!
	\reimp
*/
QString QtFlagPropertyManager::valueText(const PropertySheet* property) const
{
	const QtFlagPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	const QtFlagPropertyManagerPrivate::Data& data = it.value();

	QString str;
	int level = 0;
	const QChar bar = QLatin1Char('|');
	const QStringList::const_iterator fncend = data.flagNames.constEnd();
	for (QStringList::const_iterator it = data.flagNames.constBegin(); it != fncend; ++it) {
		if (data.val & (1 << level)) {
			if (!str.isEmpty())
				str += bar;
			str += *it;
		}

		level++;
	}
	return str;
}

/*!
	\fn void QtFlagPropertyManager::setValue(PropertySheet *property, int value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	The specified \a value must be less than the binary combination of
	the property's flagNames() list size (i.e. less than 2\sup n,
	where \c n is the size of the list) and larger than (or equal to)
	0.

	\sa value(), valueChanged()
*/
void QtFlagPropertyManager::setValue(PropertySheet* property, int val)
{
	const QtFlagPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtFlagPropertyManagerPrivate::Data data = it.value();

	if (data.val == val)
		return;

	if (val > (1 << data.flagNames.count()) - 1)
		return;

	if (val < 0)
		return;

	data.val = val;

	it.value() = data;

	const auto pfit = d_ptr->m_propertyToFlags.constFind(property);
	int level = 0;
	if (pfit != d_ptr->m_propertyToFlags.constEnd()) {
		for (PropertySheet* prop : pfit.value()) {
			if (prop)
				d_ptr->m_boolPropertyManager->setValue(prop, val & (1 << level));
			level++;
		}
	}

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	Sets the given \a property's list of flag names to \a flagNames. The
	property's current value is reset to 0 indicating the first item
	of the list.

	\sa flagNames(), flagNamesChanged()
*/
void QtFlagPropertyManager::setFlagNames(PropertySheet* property, const QStringList& flagNames)
{
	const QtFlagPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	QtFlagPropertyManagerPrivate::Data data = it.value();

	if (data.flagNames == flagNames)
		return;

	data.flagNames = flagNames;
	data.val = 0;

	it.value() = data;

	const auto pfit = d_ptr->m_propertyToFlags.find(property);
	if (pfit != d_ptr->m_propertyToFlags.end()) {
		for (PropertySheet* prop : qAsConst(pfit.value())) {
			if (prop) {
				delete prop;
				d_ptr->m_flagToProperty.remove(prop);
			}
		}
		pfit.value().clear();
	}

	for (const QString& flagName : flagNames) {
		PropertySheet* prop = d_ptr->m_boolPropertyManager->addProperty();
		prop->setPropertyName(flagName);
		property->addSubProperty(prop);
		d_ptr->m_propertyToFlags[property].append(prop);
		d_ptr->m_flagToProperty[prop] = property;
	}

	emit flagNamesChanged(property, data.flagNames);

	emit propertyChanged(property);
	emit valueChanged(property, data.val);
}

/*!
	\reimp
*/
void QtFlagPropertyManager::initializeProperty(PropertySheet* property)
{
	d_ptr->m_values[property] = QtFlagPropertyManagerPrivate::Data();

	d_ptr->m_propertyToFlags[property] = QList<PropertySheet*>();
}

/*!
	\reimp
*/
void QtFlagPropertyManager::uninitializeProperty(PropertySheet* property)
{
	const auto it = d_ptr->m_propertyToFlags.find(property);
	if (it != d_ptr->m_propertyToFlags.end()) {
		for (PropertySheet* prop : qAsConst(it.value())) {
			if (prop) {
				d_ptr->m_flagToProperty.remove(prop);
				delete prop;
			}
		}
	}
	d_ptr->m_propertyToFlags.erase(it);

	d_ptr->m_values.remove(property);
}

// QtSizePolicyPropertyManager

class QtSizePolicyPropertyManagerPrivate
{
	QtSizePolicyPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtSizePolicyPropertyManager)
public:

	QtSizePolicyPropertyManagerPrivate();

	void slotIntChanged(PropertySheet* property, int value);
	void slotEnumChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);

	typedef QMap<const PropertySheet*, QSizePolicy> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;
	QtEnumPropertyManager* m_enumPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToHPolicy;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToVPolicy;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToHStretch;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToVStretch;

	QMap<const PropertySheet*, PropertySheet*> m_hPolicyToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_vPolicyToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_hStretchToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_vStretchToProperty;
};

QtSizePolicyPropertyManagerPrivate::QtSizePolicyPropertyManagerPrivate()
{
}

void QtSizePolicyPropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_hStretchToProperty.value(property, 0)) {
		QSizePolicy sp = m_values[prop];
		sp.setHorizontalStretch(value);
		q_ptr->setValue(prop, sp);
	}
	else if (PropertySheet* prop = m_vStretchToProperty.value(property, 0)) {
		QSizePolicy sp = m_values[prop];
		sp.setVerticalStretch(value);
		q_ptr->setValue(prop, sp);
	}
}

void QtSizePolicyPropertyManagerPrivate::slotEnumChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_hPolicyToProperty.value(property, 0)) {
		QSizePolicy sp = m_values[prop];
		sp.setHorizontalPolicy(metaEnumProvider()->indexToSizePolicy(value));
		q_ptr->setValue(prop, sp);
	}
	else if (PropertySheet* prop = m_vPolicyToProperty.value(property, 0)) {
		QSizePolicy sp = m_values[prop];
		sp.setVerticalPolicy(metaEnumProvider()->indexToSizePolicy(value));
		q_ptr->setValue(prop, sp);
	}
}

void QtSizePolicyPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_hStretchToProperty.value(property, 0)) {
		m_propertyToHStretch[pointProp] = 0;
		m_hStretchToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_vStretchToProperty.value(property, 0)) {
		m_propertyToVStretch[pointProp] = 0;
		m_vStretchToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_hPolicyToProperty.value(property, 0)) {
		m_propertyToHPolicy[pointProp] = 0;
		m_hPolicyToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_vPolicyToProperty.value(property, 0)) {
		m_propertyToVPolicy[pointProp] = 0;
		m_vPolicyToProperty.remove(property);
	}
}

/*!
	\class QtSizePolicyPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtSizePolicyPropertyManager provides and manages QSizePolicy properties.

	A size policy property has nested \e horizontalPolicy, \e
	verticalPolicy, \e horizontalStretch and \e verticalStretch
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by QtIntPropertyManager and QtEnumPropertyManager
	objects. These managers can be retrieved using the subIntPropertyManager()
	and subEnumPropertyManager() functions respectively. In order to provide
	editing widgets for the subproperties in a property browser widget,
	these managers must be associated with editor factories.

	In addition, QtSizePolicyPropertyManager provides the valueChanged()
	signal which is emitted whenever a property created by this
	manager changes.

	\sa AbstractPropertyManager, QtIntPropertyManager, QtEnumPropertyManager
*/

/*!
	\fn void QtSizePolicyPropertyManager::valueChanged(PropertySheet *property, const QSizePolicy &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtSizePolicyPropertyManager::QtSizePolicyPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtSizePolicyPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));
	d_ptr->m_enumPropertyManager = new QtEnumPropertyManager(this);
	connect(d_ptr->m_enumPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotEnumChanged(PropertySheet*, int)));

	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
	connect(d_ptr->m_enumPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtSizePolicyPropertyManager::~QtSizePolicyPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the nested \e horizontalStretch
	and \e verticalStretch subproperties.

	In order to provide editing widgets for the mentioned subproperties
	in a property browser widget, this manager must be associated with
	an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtSizePolicyPropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the manager that creates the nested \e horizontalPolicy
	and \e verticalPolicy subproperties.

	In order to provide editing widgets for the mentioned subproperties
	in a property browser widget, this manager must be associated with
	an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtEnumPropertyManager* QtSizePolicyPropertyManager::subEnumPropertyManager() const
{
	return d_ptr->m_enumPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given property is not managed by this manager, this
	function returns the default size policy.

	\sa setValue()
*/
QSizePolicy QtSizePolicyPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QSizePolicy());
}

/*!
	\reimp
*/
QString QtSizePolicyPropertyManager::valueText(const PropertySheet* property) const
{
	const QtSizePolicyPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	const QSizePolicy sp = it.value();
	const QtMetaEnumProvider* mep = metaEnumProvider();
	const int hIndex = mep->sizePolicyToIndex(sp.horizontalPolicy());
	const int vIndex = mep->sizePolicyToIndex(sp.verticalPolicy());
	//! Unknown size policy on reading invalid uic3 files
	const QString hPolicy = hIndex != -1 ? mep->policyEnumNames().at(hIndex) : tr("<Invalid>");
	const QString vPolicy = vIndex != -1 ? mep->policyEnumNames().at(vIndex) : tr("<Invalid>");
	const QString str = tr("[%1, %2, %3, %4]").arg(hPolicy, vPolicy).arg(sp.horizontalStretch()).arg(sp.verticalStretch());
	return str;
}

/*!
	\fn void QtSizePolicyPropertyManager::setValue(PropertySheet *property, const QSizePolicy &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtSizePolicyPropertyManager::setValue(PropertySheet* property, const QSizePolicy& val)
{
	const QtSizePolicyPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	if (it.value() == val)
		return;

	it.value() = val;

	d_ptr->m_enumPropertyManager->setValue(d_ptr->m_propertyToHPolicy[property],
		metaEnumProvider()->sizePolicyToIndex(val.horizontalPolicy()));
	d_ptr->m_enumPropertyManager->setValue(d_ptr->m_propertyToVPolicy[property],
		metaEnumProvider()->sizePolicyToIndex(val.verticalPolicy()));
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToHStretch[property],
		val.horizontalStretch());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToVStretch[property],
		val.verticalStretch());

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\reimp
*/
void QtSizePolicyPropertyManager::initializeProperty(PropertySheet* property)
{
	QSizePolicy val;
	d_ptr->m_values[property] = val;

	PropertySheet* hPolicyProp = d_ptr->m_enumPropertyManager->addProperty();
	hPolicyProp->setPropertyName(tr("Horizontal Policy"));
	d_ptr->m_enumPropertyManager->setEnumNames(hPolicyProp, metaEnumProvider()->policyEnumNames());
	d_ptr->m_enumPropertyManager->setValue(hPolicyProp,
		metaEnumProvider()->sizePolicyToIndex(val.horizontalPolicy()));
	d_ptr->m_propertyToHPolicy[property] = hPolicyProp;
	d_ptr->m_hPolicyToProperty[hPolicyProp] = property;
	property->addSubProperty(hPolicyProp);

	PropertySheet* vPolicyProp = d_ptr->m_enumPropertyManager->addProperty();
	vPolicyProp->setPropertyName(tr("Vertical Policy"));
	d_ptr->m_enumPropertyManager->setEnumNames(vPolicyProp, metaEnumProvider()->policyEnumNames());
	d_ptr->m_enumPropertyManager->setValue(vPolicyProp,
		metaEnumProvider()->sizePolicyToIndex(val.verticalPolicy()));
	d_ptr->m_propertyToVPolicy[property] = vPolicyProp;
	d_ptr->m_vPolicyToProperty[vPolicyProp] = property;
	property->addSubProperty(vPolicyProp);

	PropertySheet* hStretchProp = d_ptr->m_intPropertyManager->addProperty();
	hStretchProp->setPropertyName(tr("Horizontal Stretch"));
	d_ptr->m_intPropertyManager->setValue(hStretchProp, val.horizontalStretch());
	d_ptr->m_intPropertyManager->setRange(hStretchProp, 0, 0xff);
	d_ptr->m_propertyToHStretch[property] = hStretchProp;
	d_ptr->m_hStretchToProperty[hStretchProp] = property;
	property->addSubProperty(hStretchProp);

	PropertySheet* vStretchProp = d_ptr->m_intPropertyManager->addProperty();
	vStretchProp->setPropertyName(tr("Vertical Stretch"));
	d_ptr->m_intPropertyManager->setValue(vStretchProp, val.verticalStretch());
	d_ptr->m_intPropertyManager->setRange(vStretchProp, 0, 0xff);
	d_ptr->m_propertyToVStretch[property] = vStretchProp;
	d_ptr->m_vStretchToProperty[vStretchProp] = property;
	property->addSubProperty(vStretchProp);
}

/*!
	\reimp
*/
void QtSizePolicyPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* hPolicyProp = d_ptr->m_propertyToHPolicy[property];
	if (hPolicyProp) {
		d_ptr->m_hPolicyToProperty.remove(hPolicyProp);
		delete hPolicyProp;
	}
	d_ptr->m_propertyToHPolicy.remove(property);

	PropertySheet* vPolicyProp = d_ptr->m_propertyToVPolicy[property];
	if (vPolicyProp) {
		d_ptr->m_vPolicyToProperty.remove(vPolicyProp);
		delete vPolicyProp;
	}
	d_ptr->m_propertyToVPolicy.remove(property);

	PropertySheet* hStretchProp = d_ptr->m_propertyToHStretch[property];
	if (hStretchProp) {
		d_ptr->m_hStretchToProperty.remove(hStretchProp);
		delete hStretchProp;
	}
	d_ptr->m_propertyToHStretch.remove(property);

	PropertySheet* vStretchProp = d_ptr->m_propertyToVStretch[property];
	if (vStretchProp) {
		d_ptr->m_vStretchToProperty.remove(vStretchProp);
		delete vStretchProp;
	}
	d_ptr->m_propertyToVStretch.remove(property);

	d_ptr->m_values.remove(property);
}

// QtFontPropertyManager:
// QtFontPropertyManagerPrivate has a mechanism for reacting
// to QApplication::fontDatabaseChanged() [4.5], which is emitted
// when someone loads an application font. The signals are compressed
// using a timer with interval 0, which then causes the family
// enumeration manager to re-set its strings and index values
// for each property.

Q_GLOBAL_STATIC(QFontDatabase, fontDatabase)

class QtFontPropertyManagerPrivate
{
	QtFontPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtFontPropertyManager)
public:

	QtFontPropertyManagerPrivate();

	void slotIntChanged(PropertySheet* property, int value);
	void slotEnumChanged(PropertySheet* property, int value);
	void slotBoolChanged(PropertySheet* property, bool value);
	void slotPropertyDestroyed(PropertySheet* property);
	void slotFontDatabaseChanged();
	void slotFontDatabaseDelayedChange();

	QStringList m_familyNames;

	typedef QMap<const PropertySheet*, QFont> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;
	QtEnumPropertyManager* m_enumPropertyManager;
	QtBoolPropertyManager* m_boolPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToFamily;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToPointSize;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToBold;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToItalic;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToUnderline;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToStrikeOut;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToKerning;

	QMap<const PropertySheet*, PropertySheet*> m_familyToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_pointSizeToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_boldToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_italicToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_underlineToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_strikeOutToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_kerningToProperty;

	bool m_settingValue;
	QTimer* m_fontDatabaseChangeTimer;
};

QtFontPropertyManagerPrivate::QtFontPropertyManagerPrivate() :
	m_settingValue(false),
	m_fontDatabaseChangeTimer(0)
{
}

void QtFontPropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (m_settingValue)
		return;
	if (PropertySheet* prop = m_pointSizeToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setPointSize(value);
		q_ptr->setValue(prop, f);
	}
}

void QtFontPropertyManagerPrivate::slotEnumChanged(PropertySheet* property, int value)
{
	if (m_settingValue)
		return;
	if (PropertySheet* prop = m_familyToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setFamily(m_familyNames.at(value));
		q_ptr->setValue(prop, f);
	}
}

void QtFontPropertyManagerPrivate::slotBoolChanged(PropertySheet* property, bool value)
{
	if (m_settingValue)
		return;
	if (PropertySheet* prop = m_boldToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setBold(value);
		q_ptr->setValue(prop, f);
	}
	else if (PropertySheet* prop = m_italicToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setItalic(value);
		q_ptr->setValue(prop, f);
	}
	else if (PropertySheet* prop = m_underlineToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setUnderline(value);
		q_ptr->setValue(prop, f);
	}
	else if (PropertySheet* prop = m_strikeOutToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setStrikeOut(value);
		q_ptr->setValue(prop, f);
	}
	else if (PropertySheet* prop = m_kerningToProperty.value(property, 0)) {
		QFont f = m_values[prop];
		f.setKerning(value);
		q_ptr->setValue(prop, f);
	}
}

void QtFontPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_pointSizeToProperty.value(property, 0)) {
		m_propertyToPointSize[pointProp] = 0;
		m_pointSizeToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_familyToProperty.value(property, 0)) {
		m_propertyToFamily[pointProp] = 0;
		m_familyToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_boldToProperty.value(property, 0)) {
		m_propertyToBold[pointProp] = 0;
		m_boldToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_italicToProperty.value(property, 0)) {
		m_propertyToItalic[pointProp] = 0;
		m_italicToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_underlineToProperty.value(property, 0)) {
		m_propertyToUnderline[pointProp] = 0;
		m_underlineToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_strikeOutToProperty.value(property, 0)) {
		m_propertyToStrikeOut[pointProp] = 0;
		m_strikeOutToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_kerningToProperty.value(property, 0)) {
		m_propertyToKerning[pointProp] = 0;
		m_kerningToProperty.remove(property);
	}
}

void  QtFontPropertyManagerPrivate::slotFontDatabaseChanged()
{
	if (!m_fontDatabaseChangeTimer) {
		m_fontDatabaseChangeTimer = new QTimer(q_ptr);
		m_fontDatabaseChangeTimer->setInterval(0);
		m_fontDatabaseChangeTimer->setSingleShot(true);
		QObject::connect(m_fontDatabaseChangeTimer, SIGNAL(timeout()), q_ptr, SLOT(slotFontDatabaseDelayedChange()));
	}
	if (!m_fontDatabaseChangeTimer->isActive())
		m_fontDatabaseChangeTimer->start();
}

void QtFontPropertyManagerPrivate::slotFontDatabaseDelayedChange()
{
	typedef QMap<const PropertySheet*, PropertySheet*> PropertyPropertyMap;
	// rescan available font names
	const QStringList oldFamilies = m_familyNames;
	m_familyNames = fontDatabase()->families();

	// Adapt all existing properties
	if (!m_propertyToFamily.empty()) {
		PropertyPropertyMap::const_iterator cend = m_propertyToFamily.constEnd();
		for (PropertyPropertyMap::const_iterator it = m_propertyToFamily.constBegin(); it != cend; ++it) {
			PropertySheet* familyProp = it.value();
			const int oldIdx = m_enumPropertyManager->value(familyProp);
			int newIdx = m_familyNames.indexOf(oldFamilies.at(oldIdx));
			if (newIdx < 0)
				newIdx = 0;
			m_enumPropertyManager->setEnumNames(familyProp, m_familyNames);
			m_enumPropertyManager->setValue(familyProp, newIdx);
		}
	}
}

/*!
	\class QtFontPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtFontPropertyManager provides and manages QFont properties.

	A font property has nested \e family, \e pointSize, \e bold, \e
	italic, \e underline, \e strikeOut and \e kerning subproperties. The top-level
	property's value can be retrieved using the value() function, and
	set using the setValue() slot.

	The subproperties are created by QtIntPropertyManager, QtEnumPropertyManager and
	QtBoolPropertyManager objects. These managers can be retrieved using the
	corresponding subIntPropertyManager(), subEnumPropertyManager() and
	subBoolPropertyManager() functions. In order to provide editing widgets
	for the subproperties in a property browser widget, these managers
	must be associated with editor factories.

	In addition, QtFontPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes.

	\sa AbstractPropertyManager, QtEnumPropertyManager, QtIntPropertyManager, QtBoolPropertyManager
*/

/*!
	\fn void QtFontPropertyManager::valueChanged(PropertySheet *property, const QFont &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the
	new \a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtFontPropertyManager::QtFontPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtFontPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;
	QObject::connect(qApp, SIGNAL(fontDatabaseChanged()), this, SLOT(slotFontDatabaseChanged()));

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));
	d_ptr->m_enumPropertyManager = new QtEnumPropertyManager(this);
	connect(d_ptr->m_enumPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotEnumChanged(PropertySheet*, int)));
	d_ptr->m_boolPropertyManager = new QtBoolPropertyManager(this);
	connect(d_ptr->m_boolPropertyManager, SIGNAL(valueChanged(PropertySheet*, bool)),
		this, SLOT(slotBoolChanged(PropertySheet*, bool)));

	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
	connect(d_ptr->m_enumPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
	connect(d_ptr->m_boolPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtFontPropertyManager::~QtFontPropertyManager()
{
	clear();
}

/*!
	Returns the manager that creates the \e pointSize subproperty.

	In order to provide editing widgets for the \e pointSize property
	in a property browser widget, this manager must be associated
	with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtFontPropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the manager that create the \e family subproperty.

	In order to provide editing widgets for the \e family property
	in a property browser widget, this manager must be associated
	with an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtEnumPropertyManager* QtFontPropertyManager::subEnumPropertyManager() const
{
	return d_ptr->m_enumPropertyManager;
}

/*!
	Returns the manager that creates the  \e bold, \e italic, \e underline,
	\e strikeOut and \e kerning subproperties.

	In order to provide editing widgets for the mentioned properties
	in a property browser widget, this manager must be associated with
	an editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtBoolPropertyManager* QtFontPropertyManager::subBoolPropertyManager() const
{
	return d_ptr->m_boolPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given property is not managed by this manager, this
	function returns a font object that uses the application's default
	font.

	\sa setValue()
*/
QFont QtFontPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QFont());
}

/*!
	\reimp
*/
QString QtFontPropertyManager::valueText(const PropertySheet* property) const
{
	const QtFontPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	return QtPropertyBrowserUtils::fontValueText(it.value());
}

/*!
	\reimp
*/
QIcon QtFontPropertyManager::valueIcon(const PropertySheet* property) const
{
	const QtFontPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QIcon();

	return QtPropertyBrowserUtils::fontValueIcon(it.value());
}

/*!
	\fn void QtFontPropertyManager::setValue(PropertySheet *property, const QFont &value)

	Sets the value of the given \a property to \a value. Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtFontPropertyManager::setValue(PropertySheet* property, const QFont& val)
{
	const QtFontPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	const QFont oldVal = it.value();
	if (oldVal == val && oldVal.resolve() == val.resolve())
		return;

	it.value() = val;

	int idx = d_ptr->m_familyNames.indexOf(val.family());
	if (idx == -1)
		idx = 0;
	bool settingValue = d_ptr->m_settingValue;
	d_ptr->m_settingValue = true;
	d_ptr->m_enumPropertyManager->setValue(d_ptr->m_propertyToFamily[property], idx);
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToPointSize[property], val.pointSize());
	d_ptr->m_boolPropertyManager->setValue(d_ptr->m_propertyToBold[property], val.bold());
	d_ptr->m_boolPropertyManager->setValue(d_ptr->m_propertyToItalic[property], val.italic());
	d_ptr->m_boolPropertyManager->setValue(d_ptr->m_propertyToUnderline[property], val.underline());
	d_ptr->m_boolPropertyManager->setValue(d_ptr->m_propertyToStrikeOut[property], val.strikeOut());
	d_ptr->m_boolPropertyManager->setValue(d_ptr->m_propertyToKerning[property], val.kerning());
	d_ptr->m_settingValue = settingValue;

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\reimp
*/
void QtFontPropertyManager::initializeProperty(PropertySheet* property)
{
	QFont val;
	d_ptr->m_values[property] = val;

	PropertySheet* familyProp = d_ptr->m_enumPropertyManager->addProperty();
	familyProp->setPropertyName(tr("Family"));
	if (d_ptr->m_familyNames.empty())
		d_ptr->m_familyNames = fontDatabase()->families();
	d_ptr->m_enumPropertyManager->setEnumNames(familyProp, d_ptr->m_familyNames);
	int idx = d_ptr->m_familyNames.indexOf(val.family());
	if (idx == -1)
		idx = 0;
	d_ptr->m_enumPropertyManager->setValue(familyProp, idx);
	d_ptr->m_propertyToFamily[property] = familyProp;
	d_ptr->m_familyToProperty[familyProp] = property;
	property->addSubProperty(familyProp);

	PropertySheet* pointSizeProp = d_ptr->m_intPropertyManager->addProperty();
	pointSizeProp->setPropertyName(tr("Point Size"));
	d_ptr->m_intPropertyManager->setValue(pointSizeProp, val.pointSize());
	d_ptr->m_intPropertyManager->setMinimum(pointSizeProp, 1);
	d_ptr->m_propertyToPointSize[property] = pointSizeProp;
	d_ptr->m_pointSizeToProperty[pointSizeProp] = property;
	property->addSubProperty(pointSizeProp);

	PropertySheet* boldProp = d_ptr->m_boolPropertyManager->addProperty();
	boldProp->setPropertyName(tr("Bold"));
	d_ptr->m_boolPropertyManager->setValue(boldProp, val.bold());
	d_ptr->m_propertyToBold[property] = boldProp;
	d_ptr->m_boldToProperty[boldProp] = property;
	property->addSubProperty(boldProp);

	PropertySheet* italicProp = d_ptr->m_boolPropertyManager->addProperty();
	italicProp->setPropertyName(tr("Italic"));
	d_ptr->m_boolPropertyManager->setValue(italicProp, val.italic());
	d_ptr->m_propertyToItalic[property] = italicProp;
	d_ptr->m_italicToProperty[italicProp] = property;
	property->addSubProperty(italicProp);

	PropertySheet* underlineProp = d_ptr->m_boolPropertyManager->addProperty();
	underlineProp->setPropertyName(tr("Underline"));
	d_ptr->m_boolPropertyManager->setValue(underlineProp, val.underline());
	d_ptr->m_propertyToUnderline[property] = underlineProp;
	d_ptr->m_underlineToProperty[underlineProp] = property;
	property->addSubProperty(underlineProp);

	PropertySheet* strikeOutProp = d_ptr->m_boolPropertyManager->addProperty();
	strikeOutProp->setPropertyName(tr("Strikeout"));
	d_ptr->m_boolPropertyManager->setValue(strikeOutProp, val.strikeOut());
	d_ptr->m_propertyToStrikeOut[property] = strikeOutProp;
	d_ptr->m_strikeOutToProperty[strikeOutProp] = property;
	property->addSubProperty(strikeOutProp);

	PropertySheet* kerningProp = d_ptr->m_boolPropertyManager->addProperty();
	kerningProp->setPropertyName(tr("Kerning"));
	d_ptr->m_boolPropertyManager->setValue(kerningProp, val.kerning());
	d_ptr->m_propertyToKerning[property] = kerningProp;
	d_ptr->m_kerningToProperty[kerningProp] = property;
	property->addSubProperty(kerningProp);
}

/*!
	\reimp
*/
void QtFontPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* familyProp = d_ptr->m_propertyToFamily[property];
	if (familyProp) {
		d_ptr->m_familyToProperty.remove(familyProp);
		delete familyProp;
	}
	d_ptr->m_propertyToFamily.remove(property);

	PropertySheet* pointSizeProp = d_ptr->m_propertyToPointSize[property];
	if (pointSizeProp) {
		d_ptr->m_pointSizeToProperty.remove(pointSizeProp);
		delete pointSizeProp;
	}
	d_ptr->m_propertyToPointSize.remove(property);

	PropertySheet* boldProp = d_ptr->m_propertyToBold[property];
	if (boldProp) {
		d_ptr->m_boldToProperty.remove(boldProp);
		delete boldProp;
	}
	d_ptr->m_propertyToBold.remove(property);

	PropertySheet* italicProp = d_ptr->m_propertyToItalic[property];
	if (italicProp) {
		d_ptr->m_italicToProperty.remove(italicProp);
		delete italicProp;
	}
	d_ptr->m_propertyToItalic.remove(property);

	PropertySheet* underlineProp = d_ptr->m_propertyToUnderline[property];
	if (underlineProp) {
		d_ptr->m_underlineToProperty.remove(underlineProp);
		delete underlineProp;
	}
	d_ptr->m_propertyToUnderline.remove(property);

	PropertySheet* strikeOutProp = d_ptr->m_propertyToStrikeOut[property];
	if (strikeOutProp) {
		d_ptr->m_strikeOutToProperty.remove(strikeOutProp);
		delete strikeOutProp;
	}
	d_ptr->m_propertyToStrikeOut.remove(property);

	PropertySheet* kerningProp = d_ptr->m_propertyToKerning[property];
	if (kerningProp) {
		d_ptr->m_kerningToProperty.remove(kerningProp);
		delete kerningProp;
	}
	d_ptr->m_propertyToKerning.remove(property);

	d_ptr->m_values.remove(property);
}

// QtColorPropertyManager

class QtColorPropertyManagerPrivate
{
	QtColorPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtColorPropertyManager)
public:

	void slotIntChanged(PropertySheet* property, int value);
	void slotPropertyDestroyed(PropertySheet* property);

	typedef QMap<const PropertySheet*, QColor> PropertyValueMap;
	PropertyValueMap m_values;

	QtIntPropertyManager* m_intPropertyManager;

	QMap<const PropertySheet*, PropertySheet*> m_propertyToR;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToG;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToB;
	QMap<const PropertySheet*, PropertySheet*> m_propertyToA;

	QMap<const PropertySheet*, PropertySheet*> m_rToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_gToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_bToProperty;
	QMap<const PropertySheet*, PropertySheet*> m_aToProperty;
};

void QtColorPropertyManagerPrivate::slotIntChanged(PropertySheet* property, int value)
{
	if (PropertySheet* prop = m_rToProperty.value(property, 0)) {
		QColor c = m_values[prop];
		c.setRed(value);
		q_ptr->setValue(prop, c);
	}
	else if (PropertySheet* prop = m_gToProperty.value(property, 0)) {
		QColor c = m_values[prop];
		c.setGreen(value);
		q_ptr->setValue(prop, c);
	}
	else if (PropertySheet* prop = m_bToProperty.value(property, 0)) {
		QColor c = m_values[prop];
		c.setBlue(value);
		q_ptr->setValue(prop, c);
	}
	else if (PropertySheet* prop = m_aToProperty.value(property, 0)) {
		QColor c = m_values[prop];
		c.setAlpha(value);
		q_ptr->setValue(prop, c);
	}
}

void QtColorPropertyManagerPrivate::slotPropertyDestroyed(PropertySheet* property)
{
	if (PropertySheet* pointProp = m_rToProperty.value(property, 0)) {
		m_propertyToR[pointProp] = 0;
		m_rToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_gToProperty.value(property, 0)) {
		m_propertyToG[pointProp] = 0;
		m_gToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_bToProperty.value(property, 0)) {
		m_propertyToB[pointProp] = 0;
		m_bToProperty.remove(property);
	}
	else if (PropertySheet* pointProp = m_aToProperty.value(property, 0)) {
		m_propertyToA[pointProp] = 0;
		m_aToProperty.remove(property);
	}
}

/*!
	\class QtColorPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtColorPropertyManager provides and manages QColor properties.

	A color property has nested \e red, \e green and \e blue
	subproperties. The top-level property's value can be retrieved
	using the value() function, and set using the setValue() slot.

	The subproperties are created by a QtIntPropertyManager object. This
	manager can be retrieved using the subIntPropertyManager() function.  In
	order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	In addition, QtColorPropertyManager provides the valueChanged() signal
	which is emitted whenever a property created by this manager
	changes.

	\sa AbstractPropertyManager, QtAbstractPropertyBrowser, QtIntPropertyManager
*/

/*!
	\fn void QtColorPropertyManager::valueChanged(PropertySheet *property, const QColor &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtColorPropertyManager::QtColorPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtColorPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;

	d_ptr->m_intPropertyManager = new QtIntPropertyManager(this);
	connect(d_ptr->m_intPropertyManager, SIGNAL(valueChanged(PropertySheet*, int)),
		this, SLOT(slotIntChanged(PropertySheet*, int)));

	connect(d_ptr->m_intPropertyManager, SIGNAL(propertyDestroyed(PropertySheet*)),
		this, SLOT(slotPropertyDestroyed(PropertySheet*)));
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtColorPropertyManager::~QtColorPropertyManager()
{
	clear();
}

/*!
	Returns the manager that produces the nested \e red, \e green and
	\e blue subproperties.

	In order to provide editing widgets for the subproperties in a
	property browser widget, this manager must be associated with an
	editor factory.

	\sa QtAbstractPropertyBrowser::setFactoryForManager()
*/
QtIntPropertyManager* QtColorPropertyManager::subIntPropertyManager() const
{
	return d_ptr->m_intPropertyManager;
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by \e this manager, this
	function returns an invalid color.

	\sa setValue()
*/
QColor QtColorPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QColor());
}

/*!
	\reimp
*/

QString QtColorPropertyManager::valueText(const PropertySheet* property) const
{
	const QtColorPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	return QtPropertyBrowserUtils::colorValueText(it.value());
}

/*!
	\reimp
*/

QIcon QtColorPropertyManager::valueIcon(const PropertySheet* property) const
{
	const QtColorPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QIcon();
	return QtPropertyBrowserUtils::brushValueIcon(QBrush(it.value()));
}

/*!
	\fn void QtColorPropertyManager::setValue(PropertySheet *property, const QColor &value)

	Sets the value of the given \a property to \a value.  Nested
	properties are updated automatically.

	\sa value(), valueChanged()
*/
void QtColorPropertyManager::setValue(PropertySheet* property, const QColor& val)
{
	const QtColorPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	if (it.value() == val)
		return;

	it.value() = val;

	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToR[property], val.red());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToG[property], val.green());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToB[property], val.blue());
	d_ptr->m_intPropertyManager->setValue(d_ptr->m_propertyToA[property], val.alpha());

	emit propertyChanged(property);
	emit valueChanged(property, val);
}

/*!
	\reimp
*/
void QtColorPropertyManager::initializeProperty(PropertySheet* property)
{
	QColor val;
	d_ptr->m_values[property] = val;

	PropertySheet* rProp = d_ptr->m_intPropertyManager->addProperty();
	rProp->setPropertyName(tr("Red"));
	d_ptr->m_intPropertyManager->setValue(rProp, val.red());
	d_ptr->m_intPropertyManager->setRange(rProp, 0, 0xFF);
	d_ptr->m_propertyToR[property] = rProp;
	d_ptr->m_rToProperty[rProp] = property;
	property->addSubProperty(rProp);

	PropertySheet* gProp = d_ptr->m_intPropertyManager->addProperty();
	gProp->setPropertyName(tr("Green"));
	d_ptr->m_intPropertyManager->setValue(gProp, val.green());
	d_ptr->m_intPropertyManager->setRange(gProp, 0, 0xFF);
	d_ptr->m_propertyToG[property] = gProp;
	d_ptr->m_gToProperty[gProp] = property;
	property->addSubProperty(gProp);

	PropertySheet* bProp = d_ptr->m_intPropertyManager->addProperty();
	bProp->setPropertyName(tr("Blue"));
	d_ptr->m_intPropertyManager->setValue(bProp, val.blue());
	d_ptr->m_intPropertyManager->setRange(bProp, 0, 0xFF);
	d_ptr->m_propertyToB[property] = bProp;
	d_ptr->m_bToProperty[bProp] = property;
	property->addSubProperty(bProp);

	PropertySheet* aProp = d_ptr->m_intPropertyManager->addProperty();
	aProp->setPropertyName(tr("Alpha"));
	d_ptr->m_intPropertyManager->setValue(aProp, val.alpha());
	d_ptr->m_intPropertyManager->setRange(aProp, 0, 0xFF);
	d_ptr->m_propertyToA[property] = aProp;
	d_ptr->m_aToProperty[aProp] = property;
	property->addSubProperty(aProp);
}

/*!
	\reimp
*/
void QtColorPropertyManager::uninitializeProperty(PropertySheet* property)
{
	PropertySheet* rProp = d_ptr->m_propertyToR[property];
	if (rProp) {
		d_ptr->m_rToProperty.remove(rProp);
		delete rProp;
	}
	d_ptr->m_propertyToR.remove(property);

	PropertySheet* gProp = d_ptr->m_propertyToG[property];
	if (gProp) {
		d_ptr->m_gToProperty.remove(gProp);
		delete gProp;
	}
	d_ptr->m_propertyToG.remove(property);

	PropertySheet* bProp = d_ptr->m_propertyToB[property];
	if (bProp) {
		d_ptr->m_bToProperty.remove(bProp);
		delete bProp;
	}
	d_ptr->m_propertyToB.remove(property);

	PropertySheet* aProp = d_ptr->m_propertyToA[property];
	if (aProp) {
		d_ptr->m_aToProperty.remove(aProp);
		delete aProp;
	}
	d_ptr->m_propertyToA.remove(property);

	d_ptr->m_values.remove(property);
}

// QtCursorPropertyManager

// Make sure icons are removed as soon as QApplication is destroyed, otherwise,
// handles are leaked on X11.
static void clearCursorDatabase();
namespace {
	struct CursorDatabase : public QtCursorDatabase
	{
		CursorDatabase()
		{
			qAddPostRoutine(clearCursorDatabase);
		}
	};
}
Q_GLOBAL_STATIC(QtCursorDatabase, cursorDatabase)

static void clearCursorDatabase()
{
	cursorDatabase()->clear();
}

class QtCursorPropertyManagerPrivate
{
	QtCursorPropertyManager* q_ptr;
	Q_DECLARE_PUBLIC(QtCursorPropertyManager)
public:
	typedef QMap<const PropertySheet*, QCursor> PropertyValueMap;
	PropertyValueMap m_values;
};

/*!
	\class QtCursorPropertyManager
	\internal
	\inmodule QtDesigner
	\since 4.4

	\brief The QtCursorPropertyManager provides and manages QCursor properties.

	A cursor property has a current value which can be
	retrieved using the value() function, and set using the setValue()
	slot. In addition, QtCursorPropertyManager provides the
	valueChanged() signal which is emitted whenever a property created
	by this manager changes.

	\sa AbstractPropertyManager
*/

/*!
	\fn void QtCursorPropertyManager::valueChanged(PropertySheet *property, const QCursor &value)

	This signal is emitted whenever a property created by this manager
	changes its value, passing a pointer to the \a property and the new
	\a value as parameters.

	\sa setValue()
*/

/*!
	Creates a manager with the given \a parent.
*/
QtCursorPropertyManager::QtCursorPropertyManager(QObject* parent)
	: AbstractPropertyManager(parent), d_ptr(new QtCursorPropertyManagerPrivate)
{
	d_ptr->q_ptr = this;
}

/*!
	Destroys this manager, and all the properties it has created.
*/
QtCursorPropertyManager::~QtCursorPropertyManager()
{
	clear();
}

/*!
	Returns the given \a property's value.

	If the given \a property is not managed by this manager, this
	function returns a default QCursor object.

	\sa setValue()
*/
#ifndef QT_NO_CURSOR
QCursor QtCursorPropertyManager::value(const PropertySheet* property) const
{
	return d_ptr->m_values.value(property, QCursor());
}
#endif

/*!
	\reimp
*/
QString QtCursorPropertyManager::valueText(const PropertySheet* property) const
{
	const QtCursorPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QString();

	return cursorDatabase()->cursorToShapeName(it.value());
}

/*!
	\reimp
*/
QIcon QtCursorPropertyManager::valueIcon(const PropertySheet* property) const
{
	const QtCursorPropertyManagerPrivate::PropertyValueMap::const_iterator it = d_ptr->m_values.constFind(property);
	if (it == d_ptr->m_values.constEnd())
		return QIcon();

	return cursorDatabase()->cursorToShapeIcon(it.value());
}

/*!
	\fn void QtCursorPropertyManager::setValue(PropertySheet *property, const QCursor &value)

	Sets the value of the given \a property to \a value.

	\sa value(), valueChanged()
*/
void QtCursorPropertyManager::setValue(PropertySheet* property, const QCursor& value)
{
#ifndef QT_NO_CURSOR
	const QtCursorPropertyManagerPrivate::PropertyValueMap::iterator it = d_ptr->m_values.find(property);
	if (it == d_ptr->m_values.end())
		return;

	if (it.value().shape() == value.shape() && value.shape() != Qt::BitmapCursor)
		return;

	it.value() = value;

	emit propertyChanged(property);
	emit valueChanged(property, value);
#endif
}

/*!
	\reimp
*/
void QtCursorPropertyManager::initializeProperty(PropertySheet* property)
{
#ifndef QT_NO_CURSOR
	d_ptr->m_values[property] = QCursor();
#endif
}

/*!
	\reimp
*/
void QtCursorPropertyManager::uninitializeProperty(PropertySheet* property)
{
	d_ptr->m_values.remove(property);
}

QT_END_NAMESPACE

#include "property_browser/moc_qtpropertymanager.cpp"
#include "qtpropertymanager.moc"